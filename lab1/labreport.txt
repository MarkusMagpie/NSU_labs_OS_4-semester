1 Компиляция, сбор зависимостей, запуск

gcc -o hello hello.c

nm hello | grep ' U '
Покажет undefined символы U:
    U __libc_start_main@GLIBC_2.34 - инициализирует и вызывает main() функцию (точка входа)
    U puts@GLIBC_2.2.5 - вывод строки на экран + "\n"
их реализация берется из стандартной библиотеки libc.so.6 - берет dynamic linker 
ld-linux-x86-64.so.2

ldd hello
показывает список динамических библиотек, которые требуются исполняемому файлу hello
включая libc.so.6, которая реализует puts() и __libc_start_main

./hello

2 Статистическая библиотека

gcc -c static_lib.c -o static_lib.o - ONLY создать объектный файл
ar rcs libstatic.a static_lib.o - создание статистической библиотеки, содержащей .o файл

изменил hello.c в функции main() для использование функции

gcc -o hello_static hello.c -L. -lstatic
компиляия и линковка главной программы с статистической библиотекой 
    -L. - искать в текущей деректории
    -lstatic - поиск и линк с исполняемым hello_static библиотеки .a

a)
nm hello_static | grep hello_from_static_lib
Проверяем на unresolved, функция не будет таковой, она T - функция определена в .text секции 
(код программы), так как код функции встроен в исполняемый файл hello_static компоновщиком

b) Где находится код функции?
objdump -d hello_static | grep hello_from_static_lib
objdump - display information from object files.
-d - Display the assembler mnemonics for the machine instructions from objfile

функция внутри hello_static, так как взята из libstatic.a на этапе коипоновки
получу буквально фдрес начала функции в памяти + call 1171 говорит что вызов функции происходит
по фиксированному адресу внутри hello_static

3 Динамическая библиотека

компиляция динамической библиотеки
gcc -shared -o libdynamic.so dynamic_lib.c

добавил функцию в hello.c

компиляия и линковка главной программы с динамической библиотекой:
gcc -o hello_dynamic hello.c -L. -ldynamic

а) Проверить состояние функции в hello_dynamic + Объяснить
nm hello_dynamic | grep hello_from_dynamic_lib
sorokinm@sorokinm-CREFG-XX:~/Desktop/NSU_labs_OS_4semester/lab1$ nm hello_dynamic | grep hello_from_dynamic_lib
            U hello_from_dynamic_lib
Так как функция не встроена, а загружается во время выполнения!

для запуска надо указать путь к библиотеке:
sorokinm@sorokinm-CREFG-XX:~/Desktop/NSU_labs_OS_4semester/lab1$ ./hello_dynamic 
./hello_dynamic: error while loading shared libraries: libdynamic.so: cannot open shared object file: No such file or directory
sorokinm@sorokinm-CREFG-XX:~/Desktop/NSU_labs_OS_4semester/lab1$ LD_LIBRARY_PATH=. ./hello_dynamic
Hello, world!
Hello from dynamic library

STATIC VSS DYNAMIC LIBRARIES
https://stackoverflow.com/questions/140061/when-to-use-dynamic-vs-static-libraries

4 динамическая библиотека с функцией hello_from_dyn_runtime_lib() и загрузить ее в hello.c 
с помощью dlopen(3). Объяснить что происходит.

сделал файл dyn_runtime_lib.c

скомпилировал: gcc -shared -o libdyn_runtime.so dyn_runtime_lib.c - создана динамическая библиотека

далее надо изменить hello.c для загрузки билиотеки во время выполнения:
    dlopen("./libdyn_runtime.so", RTLD_LAZY) - Загружает libdyn_runtime.so в память
    https://man7.org/linux/man-pages/man3/dlopen.3.html
    RTLD_LAZY - символы загружаются только при их первом использовании

    dlsym(handle, "hello_from_dyn_runtime_lib") - адрес функции hello_from_dyn_runtime_lib()
    https://pubs.opengroup.org/onlinepubs/009696899/functions/dlsym.html

    hello() - вызов функции из загруженной библиотеки

    dlclose(handle); - освободил библиотеку из памяти

Компиляция hello.c: gcc -o hello_runtime hello.c -ldl
    -ldl -  подключаеv библиотеку libdl

LD_LIBRARY_PATH=. ./hello_runtime
