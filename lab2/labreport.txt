Систе́мный вы́зов — обращение прикладной программы к ядру операционной системы для выполнения какой-либо операции.
A system call is a way for programs to interact with the operating system. (Взаимодействие между user space и kernel space; 
    картинка: https://phoenixnap.com/kb/system-call#:~:text=System%20calls%20enable%20processes%20to,%2C%20and%20I%2FO%20devices

Можно сказать про различные виды:
https://www.geeksforgeeks.org/introduction-of-system-call/



2.1
? какую проблему решает системные вызовы (историческая справка)
примерно так обстояли дела в старых системах MS/DOS: 
    не было разделения между кодом ядра и пользовательским кодом, 
    пользовательский код мог свободно напрямую обращаться к оборудованию.

    Справка: MS-DOS (англ. MicroSoft Disk Operating System) — однозадачная дисковая операционная система для компьютеров на базе архитектуры x86. 
    https://ru.wikipedia.org/wiki/MS-DOS

    2 основные проблемы: 
        1) отсутствие разделения между пространствами работает в однопользовательской и/или однозадачной системе, 
            но как только в системе одновременно запускается несколько программ, необходимо синхронизировать 
            доступ к оборудованию и использование памяти - эти задачи возлагаются на ядро.
        2) нет защиты системы от плохо написанной программы. В современных ОС ошибочная программа может завершиться сбоем, 
            но сама система должна продолжить работу. А в MS/DOS сбой программы приводил к перезагрузке системы.
    
    Все современные ОС используют изоляцию между пользовательскими процессами и процессами ядра. Значит, что нужен способ, 
        позволяющий пользовательскому процессу запрашивать привилегированные действия у ядра (например тот же syscall write). 
        Именно для этого и существуют системные вызовы.

Откуда брал ответ: https://stackoverflow.com/questions/50626460/why-do-system-calls-exist
User space and Kernel space: https://en.wikipedia.org/wiki/User_space_and_kernel_space#:~:text=Kernel%20space%20is%20strictly%20reserved,one%20address%20space%20per%20process.



2.1
? кто контролирует что программа не может напрямую обратиться к оборудованию (hardware access)?
1 вариант (по интеренту)
- Пример ответа: https://www.quora.com/How-does-an-OS-takes-control-of-hardware-Why-cant-I-just-write-a-C-program-and-take-control-of-all-my-computer
  When уou run user programs, they run in user mode. Because the programs are running in user mode, 
    you can’t just “write a C program” that “takes over your computer”. But, if you have the proper privileges, 
    you can add code to the kernel which then operates in kernel mode. And it can truly do anything. 
    But it isn’t “A C program” in the usual sense; it is something that runs with elevated privilege. 

  Кольца защиты - процессор разделяет выполнение кода на уровни (Ring 0 - для ядра, Ring 3 - для user программ)
  Пример: если программа в Ring 3 попытается выполнить привилегированную инструкцию 
  (например, in, out для доступа к портам ввода-вывода), процессор автоматически сгенерирует исключение

- процессор обнаруживает нарушение (запрещённую инструкцию) -> управление передаётся ядру. Ядро решает, завершить программу или обработать ошибку.

2 вариант (по лекции)
    1) CPU 
        P и NP - то есть CPU запрещает выполнение привилегированных команд (in, out, доступ к портам) в NP режиме.
        IDT - прорверка PL
    2) Ядро ОС
        настройка IST - NP прерывания
        адрса обработчиков прерываний и их PL
        


2.1
? разница в поведении функций int (interrupt) и call() 
INT n программа вызова програмного прерывания и соответственно передает управление в соответствующий обработчик.

CALL n - вызов процедуры. (передаёт управление по адресу, который передаётся в команду параметром)

команда CALL передаёт управление по адресу, который передаётся в команду в качестве параметра. Процессор начинает выполнять команду, расположенную по этому адресу.
Различия: 
    1) Назначение
    INT используется для вызова обработчиков прерываний, переходя из пользовательского режима в режим ядра (с переключением привилегий)
    CALL применяется для обычных вызовов подпрограмм в рамках одного адресного пространства (без смены режима и без обращения к таблице векторов прерываний)
    2) Механизм перехода
    INT сначала ищет адрес обработчика через таблицу векторов прерываний IDT, и, в защищённом режиме, возможность осуществить переключение уровней привилегий.
    CALL передаёт управление процедуре непосредственно по адресу

INT n в общем ведет себя как дальний вызов командой CALL, за исключением того, что регистр флагов помещается в стек перед адресом возврата.

ПЕРЕД ОТВЕТОМ открой: 
определение INT: https://www.club155.ru/x86cmd/INTn и о том как идет выполнение команды
про определение ПРЕРЫВАНИЯ и как оно происходит: https://www.club155.ru/x86exceptions-types#soft
https://ru.wikipedia.org/wiki/Регистр_флагов - отсюда взял строку: 
    "когда активизируется обработчик прерывания или обработчик исключительной ситуации, процессор автоматически сохраняет значение регистра флагов в текущем стеке."
определение CALL: https://www.club155.ru/x86cmd/CALL
2 ответа которые плохо структурированы: https://www.quora.com/Can-you-explain-the-difference-between-int-and-call-in-assembly-language
                                        https://stackoverflow.com/questions/26445302/int-vs-call-on-asm-instructions#:~:text=Superficially%2C%20the%20difference%20is%3A,to%20look%20up%20the%20address.



? почему INT принимает индеекс таблицы а не произвольный адрес?
- безопасный переход между режимами CPU
  У нас есть таблица IDT адрес которой лежит регистре idtr, каждая запись таблицы содержит: адрес обработчика прерывания, PL (проверка режима).
  
  Важно: если бы INT принимал любой адрес, то пользовательские программы могли бы напрямую вызывать любой код 
    в режиме ядра, минуя проверку PL. Это нарушило бы изоляцию между режимами P и NP.

  Важно: если бы INT принимал адрес, а не индекс, то процессор не смог бы проверить, разрешён ли 
    вызов этого кода из текущего режима (P или NP). Система была бы уязвимой для произвольного выполнения привилегированного кода.

  Ядро настраивает IDT так, чтобы только определённые прерывания (int 0x80 для системных вызовов) были доступны из пользовательского режима (NP).
    А если бы INT работал с адресами, юзер мог бы подменить адрес обработчика на свой.

  Защита от вызова функций в P режиме: 
    1) нам (юзеру) не хватает привилегий (NP режим по умолчанию)
    2) при вызове функции в user space мы тупо не знаем где она находится в памяти в kernel зоне.
  А механизм вызова - прерывание.

  ? вот мы что-то разделяем... а зачем? Зачем разделение на режимы P и NP у CPU ?
  - опять же безопасность. Если бы юзер программы могли напрямую выполнять команды ядра, то был бы атас. Например по лекции: 
    мог бы подменить своим кодом обработчики прерываний (через IDT) или системные вызовы.
  
  Про режимы и моды: https://takeuforward.org/operating-system/kernel-user-models



2.2
? если использовать write - можно получить проблему которой нет с использованием fputs - какую? (чем fputs отличается от write?)
1 вариант - БУФЕРИЗАЦИЯ
- fputs - высокоуровненвая функция стандартной бибдиотеки C
  write - syscall.

- puts() - автоматически доавляет символ новой строки '\n' в конец строки.
  write() - запись указанного числа байтов данных БЕЗ ИЗМЕНЕНИЙ (не добавляет '\n').  

- fputs использует буферизацию стандартной библиотеки C.  
! То есть данные накапливаются в буфере перед выводом. Буфер сбрасывается при явном вызове fflush(stdout) или при завершении программы.
  Если имеем несколько мелких выводов то требуется только один сискол.

! Может быть эффективнее для частых мелких записей благодаря буферизации. Так как количество сисколов минимизируется.
  Например: запись 100 байт через write но по 1 байту. С буферизованной функцией fputs у нас 1 сискол ибо 100 байт все идут в буффер, 
    когда понадобится вывести данные из буфера, у нас будет всего 1 сискол и 1 переключение контекста соответственно (лучше чем 100 сисколов). 
    А 100 сисколов очевидно оказывает большую нагрузку на ядро чем 1.

  ? Почему боимся делать много сисколов? 
  - Каждый системный вызов требует переключения между user и kernel mode (context switch). 
    А переключение как раз и дает накладные расходы по времени. 
    В пример можно показать картинку: https://phoenixnap.com/kb/system-call#:~:text=System%20calls%20enable%20processes%20to,%2C%20and%20I%2FO%20devices

    ? что подразумевается под переключением контекста? 
    -   1 сохранение регистров на стек; 
        2 проверка прав доступа (уровня привилегии)
        3 выполняется kernel функция в зависимости от исплняемого сискола
        4 возвращение значения сискола в пользовательский режим (восстановление контекста)
        
2 вариант - ПОТОКОБЕЗОПАСНОСТЬ
Написано здесь: https://stackoverflow.com/questions/70537479/write-syscall-gets-considerably-slower-when-called-from-another-thread
При даже 2 тредах syscall write занимает существенно больше времени.

Покажи файл syscalltest.c - fputs буфферизует, 1 сискол быстрее нескольких
gcc -o test syscalltest.c 
strace ./test 



2.2 ? почему context switch - долгая операция - подробно - все
- 1) чтобы сделать syscall нужно обратиться к функциям, лежащим в пространстве ядра. А перед переключением контекста в памяти находится моя программа,
  соответственно мне нужно при переключении контекста обратиться к памяти и найти в ней нужные функции в пространстве ядра, а обращение в память само долгое.
  2) TLB (Translation Lookaside Buffer) - аппаратный кэш процессора, ускоряющий трансляцию виртуальных адресов в физические. 
     Он хранит недавно использованные записи таблиц страниц, чтобы избежать многократных обращений к памяти. 
     Но при переключении контекста TLB может стать источником уязвимостей, если его содержимое не будет корректно обновлено.
  
     Если целевая задача при переключении контекста использует отличный от предыдущего контекст памяти (каталог страниц и таблицы страницы), 
     происходит очистка TLB, таким образом при последующих обращениях в память снижается производительность процессора 
     (необходима подгрузка записей таблицы страниц в пустой TLB). 

    Процесс переключения контекса:
    1 прерывание программы
    2 сохранение в памяти значений регистров общего назначения + счетчика команд
    2.1 сохранение адресного пространства - если перекдючение между процессами с разными пространтсвами, ОБНОВЛЯЕМ базовый адрес каталога страниц и очищаем TLB.
    3 переключение адресного пространства и обновление состояния процессор
    4 восстановление регистров, TLB, 
    5 возвращение в user mode

    Иртегов (страница 285)
    про TLB при переключении контекса: https://ru.wikipedia.org/wiki/Буфер_ассоциативной_трансляции



2.2 ? можно ли использовать стек прикладной программы при syscall
- физически, учитывая что есть право, мы можем. Но на практике когда мы используем стек, после завершения некоторой подпрограммы например,
  он не очищается, мы просто передвигаем указатель на конец стека. А значит, что была бы проблема с безопасностью так как код из NP режима
  мог бы получить доаступ к оставшимся на стеке данным из привилегированного режима. 
  


2.2 ? любое ли обращение к памяти требует трансляции памяти из виртуальной в физическую ?
    - MMU - аппаратный компонент, отвечающий за управление доступом к памяти, в частности за трансляцию виртуальных адресов в физические.
      Определение: https://ru.wikipedia.org/wiki/Блок_управления_памятью
      
      В системах с виртуальной памятью (protected mode) процессор оперирует виртуальными адресами. 
        MMU, используя page table и буфер ассоциативной трансляции (TLB), преобразует эти виртуальные адреса в физические.

    - режимы работы процессора: 
      1) Real Mode: 
          Real Mode - 16-битный режим, который присутствует на всех процессорах x86. 
            Real mode был первой конструкцией режима X86 и использовался многими ранними операционными системами до появления Protected. 
            Для совместимости все процессоры x86 начинают исполнение в реальном режиме.
          нет виртуальной памяти: Real Mode (используется при загрузке и в DOS) адресация физическая
          MMU не используется: страничная трансляция отключена -> MMU не выполняет преобразование адресов

          Можно показать раздел Memory Adressing из сслки ниже - физический адрес формируется по формуле: PhysicalAddress = Segment * 16 + Offset

          https://wiki.osdev.org/Real_Mode

      2) Protected Mode 
          Если включена страничная организация, MMU преобразует виртуальные адреса в физические через page table
          Если страницы отключены, используется прямая физическая адресация (но с защитой через сегменты).

          https://wiki.osdev.org/Protected_Mode

    - мне известно что в текущей ОС используется страничная организация (Paging), которая используется для реализации виртуальной памяти.
         Paging работает только в protected mode, а не в real mode. 
      Ответ отсюда: http://www.osdever.net/tutorials/view/the-world-of-protected-mode

    - при context switch помимо сохранения регистров общего назначения, сохраняем регистр CR3:
        он содержит физический адрес каталога страниц (он же page directory он же таблицы указателей каталогов страниц), 
        а page directory хранит адреса элементов page table, которые уже сопсоставляют виртуальные адреса физическим.
        CR3 указывает MMU, где искать иерархию таблиц для трансляции виртуальных адресов в физические.
      про регистр CR3: https://osdev.fandom.com/ru/wiki/CR3
      про context switch: https://wiki.osdev.org/Context_Switching
      картинка для примера: https://en.wikipedia.org/wiki/Control_register#/media/File:X86_Paging_4K.svg

    - изначально ЦП, который инициализируется BIOS, начинается в реальном режиме. В нет виртуальной памяти - адресация физическая. Linux ядро 
        само перелючает режим CPU в protected (ответ: https://stackoverflow.com/questions/4821911/does-grub-switch-to-protected-mode 
        (загрузчик ОС GRUB - первые 512 байт на диске)), а в protcted mode преобразованием вирт адресов в физ занимается MMU.  



1
    a 
        i 
        Сделал hello.c, скомпилировал: gcc -o hello hello.c и запустил strace ./hello далее ответы на вопросы:

        Какие системные вызовы были вызваны в процессе исполнения программы? 
        Чем обусловлено такое количество системных вызовов?
        Какой системный вызов используется для вывода “hello world”? 
        Изучите этот вызов и разберитесь что он принимает и возвращает.

        Системные вызовы: openat, mmap, mprotect, read, close
            int openat(int dirfd, const char *pathname, int flags);
            Это системный вызов в Linux, позволяет открывать файлы относительно указанного каталога. Он является расширенной версией open().
            Получив в pathname имя файла, open() возвращает файловый дескриптор - небольшое, неотрицательное значение для использования в последующих системных вызовах.
            Вызов open() создаёт новое открытое файловое описание — запись в системной таблице открытых файлов. 
                В этой записи хранится смещение и флаги состояния файла (смотрите ниже). 
                Файловый дескриптор — это ссылка на открытое файловое описание; 
                    с этой ссылкой ничего не происходит при последующем удалении pathname или переуказании имени на другой файл.
            Про openat: https://ru.manpages.org/openat/2

            Пример работы из вывода strace:
            openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3 - открыл libc.so.6 для чтения 
            ...
            close(3)  - закрытие файла libc.so.6

            void * mmap(void *start, size_t length, int prot , int flags, int fd, off_t offset);
            Функция mmap отражает length байтов, начиная со смещения offset файла (или другого объекта), 
                определенного файловым дескриптором fd, в память, начиная с адреса start. 
            Последний параметр (адрес) необязателен, и обычно бывает равен 0. 
            Настоящее местоположение отраженных данных возвращается самой функцией mmap, и никогда не бывает равным 0.
            Аргумент prot описывает желаемый режим защиты памяти (он не должен конфликтовать с режимом открытия файла). 
                Оно является либо PROT_NONE либо побитовым ИЛИ одного или нескольких флагов PROT_*.
            Про mmap: https://www.opennet.ru/man.shtml?topic=mmap&category=2&russian=0

            ssize_t read(int fd, void *buf, size_t count);
            read() attempts to read up to count bytes from file descriptor fd into the buffer starting at buf.
            https://linux.die.net/man/2/read

            close - close a file descriptor
            https://man7.org/linux/man-pages/man2/close.2.html

            int mprotect(const void *addr, size_t len, int prot);
            mprotect контролирует доступ к области памяти. Если программой производится запрещенный этой функцией доступ к памяти, 
                то такая программа получает сигнал SIGSEGV.
            Про mprotect: https://www.opennet.ru/man.shtml?topic=mprotect&category=2&russian=0

            write(int fd, const void buf[.count], size_t count);
            write() writes up to count bytes from the buffer starting at buf
                to the file referred to by the file descriptor fd.
            системный вызов, который используется для записи данных из буфера в файл или другое устройство, представленное файловым дескриптором.
            RETURN VALUE: On success, the number of bytes written is returned.  On error, -1 is returned, and errno is set to indicate the error.
            Про write: https://man7.org/linux/man-pages/man2/write.2.html

            exit_group() - exit all threads in a process


        Вывод текста происходит с помощью системного вызова write(1, "Hello, world!\n", 14Hello, world!) = 14
            записываем строку "Hello, world!\n" длиной 14 байт в файловый дескриптор 1 (консоль?) 
            Return value = 14 -> все 14 байт были успешно записаны

        +++ exited with 0 +++, in the last line states that exit status is 0 which means there was no error. 
            In case of an error, the exit code is -1.

        ? Че так много вызовов ?
        - The only actually necessary system calls for a Hello-World are write(stdout, "Hello World", 11) and exit(). 
        Any others are coming from the runtime library of the language you used for development, and are there to 
        support features used in more complex programs.



        ii
        Используйте сискол в программе hello world вместо printf(). 
        Убедитесь что этот вызов присутствует в выводе strace.

        https://man7.org/linux/man-pages/man2/write.2.html

        ssize_t write(int fd, const void buf[.count], size_t count);
        fd - file descriptor в который и будут записаны данные, у меня равен 1 - это стандартный вывод.
        buf - указатель на буфер с данными ("Hello, world!\n")
        count - количество байт для записи
        ! в случае успешной записи нам вернется 14 - число записанных байт 

        компиляция и запуск с strace новой программы: 
        gcc -o hello_write hello.c
        strace ./hello_write

        Да, действительно вывод присутствует в выводе trace: write(1, "Hello, world!\n", 14Hello, world!) = 14

        Разница между write() и printf(): https://stackoverflow.com/questions/21084218/difference-between-write-and-printf



        iii
        напишите свою обертку над этим сисколом. Для этого используйте функцию syscall() из libc. 
        Также проверьте вывод strace.

        компиляция и запуск с strace:
        gcc -o hello_syscall hello.c
        strace ./hello_syscall

        в выводе strace опять вижу write(1, "hello, world!\n", 14hello, world!) = 14 а значит вызвал write() 
            через syscall 

    b   Запустите под strace команду ‘wget kernel.org’ (если нет wget, используйте curl). 
        Получите статистику использования системных вызовов порожденным процессом.
    strace wget kernel.org

    вообще чтобы собрать статистику системных вызовов, можно сделать так: strace -c wget kernel.org

    wget - утилита для загрузки файлов из сети. В нашем случае она пытается загрузить содержимое с сайта 
    kernel.org, а при этом strace перехватывает и выводит все системные вызовы, 
    которые выполняются процессом wget

2 Разберитесь как устроена функция syscall(). Напишите код, который напечатает hello world без использования функции syscall().
    Разбор ассемблерных вставок:

    volatile чтобы предотвратить оптимизацию вставок компилятором
    In AT&T however registers are prefixed with a '%' and immed's are prefixed with a '$'.
    
    https://imada.sdu.dk/u/kslarsen/dm546/Material/IntelnATT.htm

    _start:
        movl    $write, %eax    // system call number (sys_write)
        movl    $1, %ebx        // file descriptor (stdout)
        lea     str, %ecx       // message to write
        movl    $len, %edx      // message length
        int     $0x80           // call kernel

        movl    $exit, %eax     // system call number (sys_exit)
        xorl    %ebx, %ebx 
        int     $0x80
    .data
    str:    .ascii "Hello, world!\n"
    len = . -str
    .globl  _start

    Скомпилируем программу: as -o hello.o hello.S - создан объектный файл hello.of
                            ld -o hellob hello.o - линковка объектного файла в executable файл

    https://www.tutorialspoint.com/assembly_programming/assembly_registers.htm
    https://stackoverflow.com/questions/1690893/hello-world-without-using-libraries
