Систе́мный вы́зов — обращение прикладной программы к ядру операционной системы для выполнения какой-либо операции.
A system call is a way for programs to interact with the operating system. (Взаимодействие между user space и kernel space; 
    картинка: https://phoenixnap.com/kb/system-call#:~:text=System%20calls%20enable%20processes%20to,%2C%20and%20I%2FO%20devices

Можно сказать про различные виды:
https://www.geeksforgeeks.org/introduction-of-system-call/



2.1
? какую проблему решает системные вызовы (историческая справка)
примерно так обстояли дела в старых системах MS/DOS: 
    не было разделения между кодом ядра и пользовательским кодом, 
    пользовательский код мог свободно напрямую обращаться к оборудованию.

    Справка: MS-DOS (англ. MicroSoft Disk Operating System) — однозадачная дисковая операционная система для компьютеров на базе архитектуры x86. 
    https://ru.wikipedia.org/wiki/MS-DOS

    2 основные проблемы: 
        1) отсутствие разделения между пространствами работает в однопользовательской и/или однозадачной системе, 
            но как только в системе одновременно запускается несколько программ, необходимо синхронизировать 
            доступ к оборудованию и использование памяти - эти задачи возлагаются на ядро.
        2) нет защиты системы от плохо написанной программы. В современных ОС ошибочная программа может завершиться сбоем, 
            но сама система должна продолжить работу. А в MS/DOS сбой программы приводил к перезагрузке системы.
    
    Все современные ОС используют изоляцию между пользовательскими процессами и процессами ядра. Значит, что нужен способ, 
        позволяющий пользовательскому процессу запрашивать привилегированные действия у ядра (например тот же syscall write). 
        Именно для этого и существуют системные вызовы.

Откуда брал ответ: https://stackoverflow.com/questions/50626460/why-do-system-calls-exist
User space and Kernel space: https://en.wikipedia.org/wiki/User_space_and_kernel_space#:~:text=Kernel%20space%20is%20strictly%20reserved,one%20address%20space%20per%20process.



2.1
? кто контролирует что программа не может напрямую обратиться к оборудованию (hardware access)?
1 вариант (по интеренту)
- Пример ответа: https://www.quora.com/How-does-an-OS-takes-control-of-hardware-Why-cant-I-just-write-a-C-program-and-take-control-of-all-my-computer
  When уou run user programs, they run in user mode. Because the programs are running in user mode, 
    you can’t just “write a C program” that “takes over your computer”. But, if you have the proper privileges, 
    you can add code to the kernel which then operates in kernel mode. And it can truly do anything. 
    But it isn’t “A C program” in the usual sense; it is something that runs with elevated privilege. 

  Кольца защиты - процессор разделяет выполнение кода на уровни (Ring 0 - для ядра, Ring 3 - для user программ)
  Пример: если программа в Ring 3 попытается выполнить привилегированную инструкцию 
  (например, in, out для доступа к портам ввода-вывода), процессор автоматически сгенерирует исключение

- процессор обнаруживает нарушение (запрещённую инструкцию) -> управление передаётся ядру. Ядро решает, завершить программу или обработать ошибку.

2 вариант (по лекции)
    1) CPU 
        P и NP - то есть CPU запрещает выполнение привилегированных команд (in, out, доступ к портам) в NP режиме.
        IDT - прорверка PL
    2) Ядро ОС
        настройка IST - NP прерывания
        адрса обработчиков прерываний и их PL
        


2.1
? разница в поведении функций int (interrupt) и call() 
INT n программа вызова програмного прерывания и соответственно передает управление в соответствующий обработчик.

CALL n - вызов процедуры. (передаёт управление по адресу, который передаётся в команду параметром)

команда CALL передаёт управление по адресу, который передаётся в команду в качестве параметра. Процессор начинает выполнять команду, расположенную по этому адресу.
Различия: 
    1) Назначение
    INT используется для вызова обработчиков прерываний, переходя из пользовательского режима в режим ядра (с переключением привилегий)
    CALL применяется для обычных вызовов подпрограмм в рамках одного адресного пространства (без смены режима и без обращения к таблице векторов прерываний)
    2) Механизм перехода
    INT сначала ищет адрес обработчика через таблицу векторов прерываний IDT, и, в защищённом режиме, возможность осуществить переключение уровней привилегий.
    CALL передаёт управление процедуре непосредственно по адресу

INT n в общем ведет себя как дальний вызов командой CALL, за исключением того, что регистр флагов помещается в стек перед адресом возврата.

ПЕРЕД ОТВЕТОМ открой: 
определение INT: https://www.club155.ru/x86cmd/INTn и о том как идет выполнение команды
про определение ПРЕРЫВАНИЯ и как оно происходит: https://www.club155.ru/x86exceptions-types#soft
https://ru.wikipedia.org/wiki/Регистр_флагов - отсюда взял строку: 
    "когда активизируется обработчик прерывания или обработчик исключительной ситуации, процессор автоматически сохраняет значение регистра флагов в текущем стеке."
определение CALL: https://www.club155.ru/x86cmd/CALL
2 ответа которые плохо структурированы: https://www.quora.com/Can-you-explain-the-difference-between-int-and-call-in-assembly-language
                                        https://stackoverflow.com/questions/26445302/int-vs-call-on-asm-instructions#:~:text=Superficially%2C%20the%20difference%20is%3A,to%20look%20up%20the%20address.



? почему INT принимает индеекс таблицы а не произвольный адрес?
- безопасный переход между режимами CPU
  У нас есть таблица IDT адрес которой лежит регистре idtr, каждая запись таблицы содержит: адрес обработчика прерывания, PL (проверка режима).
  
  Важно: если бы INT принимал любой адрес, то пользовательские программы могли бы напрямую вызывать любой код 
    в режиме ядра, минуя проверку PL. Это нарушило бы изоляцию между режимами P и NP.

  Важно: если бы INT принимал адрес, а не индекс, то процессор не смог бы проверить, разрешён ли 
    вызов этого кода из текущего режима (P или NP). Система была бы уязвимой для произвольного выполнения привилегированного кода.

  Ядро настраивает IDT так, чтобы только определённые прерывания (int 0x80 для системных вызовов) были доступны из пользовательского режима (NP).
    А если бы INT работал с адресами, юзер мог бы подменить адрес обработчика на свой.

  Защита от вызова функций в P режиме: 
    1) нам (юзеру) не хватает привилегий (NP режим по умолчанию)
    2) при вызове функции в user space мы тупо не знаем где она находится в памяти в kernel зоне.
  А механизм вызова - прерывание.

  ? вот мы что-то разделяем... а зачем? Зачем разделение на режимы P и NP у CPU ?
  - опять же безопасность. Если бы юзер программы могли напрямую выполнять команды ядра, то был бы атас. Например по лекции: 
    мог бы подменить своим кодом обработчики прерываний (через IDT) или системные вызовы.
  
  Про режимы и моды: https://takeuforward.org/operating-system/kernel-user-models



2.2
? если использовать write - можно получить проблему которой нет с использованием fputs - какую? (чем fputs отличается от write?)
1 вариант - БУФЕРИЗАЦИЯ
- fputs - высокоуровненвая функция стандартной бибдиотеки C
  write - syscall.

- puts() - автоматически доавляет символ новой строки '\n' в конец строки.
  write() - запись указанного числа байтов данных БЕЗ ИЗМЕНЕНИЙ (не добавляет '\n').  

- fputs использует буферизацию стандартной библиотеки C.  
! То есть данные накапливаются в буфере перед выводом. Буфер сбрасывается при явном вызове fflush(stdout) или при завершении программы.
  Если имеем несколько мелких выводов то требуется только один сискол.

! Может быть эффективнее для частых мелких записей благодаря буферизации. Так как количество сисколов минимизируется.
  Например: запись 100 байт через write но по 1 байту. С буферизованной функцией fputs у нас 1 сискол ибо 100 байт все идут в буффер, 
    когда понадобится вывести данные из буфера, у нас будет всего 1 сискол и 1 переключение контекста соответственно (лучше чем 100 сисколов). 
    А 100 сисколов очевидно оказывает большую нагрузку на ядро чем 1.

  ? Почему боимся делать много сисколов? 
  - Каждый системный вызов требует переключения между user и kernel mode (context switch). 
    А переключение как раз и дает накладные расходы по времени. 
    В пример можно показать картинку: https://phoenixnap.com/kb/system-call#:~:text=System%20calls%20enable%20processes%20to,%2C%20and%20I%2FO%20devices

    ? что подразумевается под переключением контекста? 
    -   1 сохранение регистров на стек; 
        2 проверка прав доступа (уровня привилегии)
        3 выполняется kernel функция в зависимости от исплняемого сискола
        4 возвращение значения сискола в пользовательский режим (восстановление контекста)
        
2 вариант - ПОТОКОБЕЗОПАСНОСТЬ
Написано здесь: https://stackoverflow.com/questions/70537479/write-syscall-gets-considerably-slower-when-called-from-another-thread
При даже 2 тредах syscall write занимает существенно больше времени.

Покажи файл syscalltest.c - fputs буфферизует, 1 сискол быстрее нескольких
gcc -o test syscalltest.c 
strace ./test 



2.2 ? почему context switch - долгая операция - подробно - все
- 1) чтобы сделать syscall нужно обратиться к функциям, лежащим в пространстве ядра. А перед переключением контекста в памяти находится моя программа,
  соответственно мне нужно при переключении контекста обратиться к памяти и найти в ней нужные функции в пространстве ядра, а обращение в память само долгое.
  2) TLB (Translation Lookaside Buffer) - аппаратный кэш процессора, ускоряющий трансляцию виртуальных адресов в физические. 
     Он хранит недавно использованные записи таблиц страниц, чтобы избежать многократных обращений к памяти. 
     Но при переключении контекста TLB может стать источником уязвимостей, если его содержимое не будет корректно обновлено.
  
     Если целевая задача при переключении контекста использует отличный от предыдущего контекст памяти (каталог страниц и таблицы страницы), 
     происходит очистка TLB, таким образом при последующих обращениях в память снижается производительность процессора 
     (необходима подгрузка записей таблицы страниц в пустой TLB). 

    Процесс переключения контекса:
    1 прерывание программы
    2 сохранение в памяти значений регистров общего назначения + счетчика команд
    2.1 сохранение адресного пространства - если перекдючение между процессами с разными пространтсвами, ОБНОВЛЯЕМ базовый адрес каталога страниц и очищаем TLB.
    3 переключение адресного пространства и обновление состояния процессор
    4 восстановление регистров, TLB, 
    5 возвращение в user mode

    Иртегов (страница 285)
    про TLB при переключении контекса: https://ru.wikipedia.org/wiki/Буфер_ассоциативной_трансляции



2.2 ? можно ли использовать стек прикладной программы при syscall
- физически, учитывая что есть право, мы можем. Но на практике когда мы используем стек, после завершения некоторой подпрограммы например,
  он не очищается, мы просто передвигаем указатель на конец стека. А значит, что была бы проблема с безопасностью так как код из NP режима
  мог бы получить доаступ к оставшимся на стеке данным из привилегированного режима. 
  


2.2 ? любое ли обращение к памяти требует трансляции памяти из виртуальной в физическую ?
    - MMU - аппаратный компонент, отвечающий за управление доступом к памяти, в частности за трансляцию виртуальных адресов в физические.
      Определение: https://ru.wikipedia.org/wiki/Блок_управления_памятью

      ОТКРОЙ ПЕРЕД ОТВЕТОМ: 
        https://habr.com/ru/articles/211150/ тут картинка MMU
        https://ru.wikipedia.org/wiki/Таблица_страниц тут роль таблицы страниц
      
      В системах с виртуальной памятью (protected mode) процессор оперирует виртуальными адресами. 
        MMU, используя page table и буфер ассоциативной трансляции (TLB), преобразует эти виртуальные адреса в физические.
      
      Виртуальная память - воображаемая память, выделяемая ОС для размещения пользовательской программы, ее рабочих полей и информационных массивов.

    - режимы работы процессора: 
      1) Real Mode: 
          Real Mode - 16-битный режим, который присутствует на всех процессорах x86. 
            Real mode был первой конструкцией режима X86 и использовался многими ранними операционными системами до появления Protected. 
            Для совместимости все процессоры x86 начинают исполнение в реальном режиме.
          нет виртуальной памяти: Real Mode (используется при загрузке и в DOS) адресация физическая
          MMU не используется: страничная трансляция отключена -> MMU не выполняет преобразование адресов

          Можно показать раздел Memory Adressing из сслки ниже - физический адрес формируется по формуле: PhysicalAddress = Segment * 16 + Offset

          https://wiki.osdev.org/Real_Mode

      2) Protected Mode 
          Если включена страничная организация, MMU преобразует виртуальные адреса в физические через page table
          Если страницы отключены, используется прямая физическая адресация (но с защитой через сегменты).

          https://wiki.osdev.org/Protected_Mode

    - мне известно что в текущей ОС используется страничная организация (Paging), которая используется для реализации виртуальной памяти.
         Paging работает только в protected mode, а не в real mode. 
      Ответ отсюда: http://www.osdever.net/tutorials/view/the-world-of-protected-mode

    - при context switch помимо сохранения регистров общего назначения, сохраняем регистр CR3:
        он содержит физический адрес каталога страниц (он же page directory он же таблицы указателей каталогов страниц), 
        а page directory хранит адреса элементов page table, которые уже сопсоставляют виртуальные адреса физическим.
        CR3 указывает MMU, где искать иерархию таблиц для трансляции виртуальных адресов в физические.
      про регистр CR3: https://osdev.fandom.com/ru/wiki/CR3
      про context switch: https://wiki.osdev.org/Context_Switching
      картинка для примера: https://en.wikipedia.org/wiki/Control_register#/media/File:X86_Paging_4K.svg

    - изначально ЦП, который инициализируется BIOS, начинается в реальном режиме. В нем впринципе нет виртуальной памяти - адресация физическая. Linux ядро 
        само перелючает режим CPU в protected (ответ: https://stackoverflow.com/questions/4821911/does-grub-switch-to-protected-mode 
        (загрузчик ОС GRUB - первые 512 байт на диске)), а в protected mode преобразованием вирт адресов в физ занимается MMU.  



1
    a 
        i 
        Сделал hello.c, скомпилировал: gcc -o hello hello.c и запустил strace ./hello далее ответы на вопросы:

        Какие системные вызовы были вызваны в процессе исполнения программы? 
        Чем обусловлено такое количество системных вызовов?
        Какой системный вызов используется для вывода “hello world”? 
        Изучите этот вызов и разберитесь что он принимает и возвращает.

        Системные вызовы: openat, mmap, mprotect, read, close
            int openat(int dirfd, const char *pathname, int flags);
            Это системный вызов в Linux, позволяет открывать файлы относительно указанного каталога. Он является расширенной версией open().
            Получив в pathname имя файла, open() возвращает файловый дескриптор - небольшое, неотрицательное значение для использования в последующих системных вызовах.
            Вызов open() создаёт новое открытое файловое описание — запись в системной таблице открытых файлов. 
                В этой записи хранится смещение и флаги состояния файла (смотрите ниже). 
                Файловый дескриптор — это ссылка на открытое файловое описание; 
                    с этой ссылкой ничего не происходит при последующем удалении pathname или переуказании имени на другой файл.
            Про openat: https://ru.manpages.org/openat/2

            Пример работы из вывода strace:
            openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3 - открыл libc.so.6 для чтения 
            ...
            close(3)  - закрытие файла libc.so.6

            void * mmap(void *start, size_t length, int prot , int flags, int fd, off_t offset);
            Функция mmap отражает length байтов, начиная со смещения offset файла (или другого объекта), 
                определенного файловым дескриптором fd, в память, начиная с адреса start. 
            Последний параметр (адрес) необязателен, и обычно бывает равен 0. 
            Настоящее местоположение отраженных данных возвращается самой функцией mmap, и никогда не бывает равным 0.
            Аргумент prot описывает желаемый режим защиты памяти (он не должен конфликтовать с режимом открытия файла). 
                Оно является либо PROT_NONE либо побитовым ИЛИ одного или нескольких флагов PROT_*.
            Про mmap: https://www.opennet.ru/man.shtml?topic=mmap&category=2&russian=0

            ssize_t read(int fd, void *buf, size_t count);
            read() attempts to read up to count bytes from file descriptor fd into the buffer starting at buf.
            https://linux.die.net/man/2/read

            close - close a file descriptor
            https://man7.org/linux/man-pages/man2/close.2.html

            int mprotect(const void *addr, size_t len, int prot);
            mprotect контролирует доступ к области памяти. Если программой производится запрещенный этой функцией доступ к памяти, 
                то такая программа получает сигнал SIGSEGV.
            Про mprotect: https://www.opennet.ru/man.shtml?topic=mprotect&category=2&russian=0

            write(int fd, const void buf[.count], size_t count);
            write() writes up to count bytes from the buffer starting at buf
                to the file referred to by the file descriptor fd.
            системный вызов, который используется для записи данных из буфера в файл или другое устройство, представленное файловым дескриптором.
            RETURN VALUE: On success, the number of bytes written is returned.  On error, -1 is returned, and errno is set to indicate the error.
            Про write: https://man7.org/linux/man-pages/man2/write.2.html

            exit_group() - exit all threads in a process


        Вывод текста происходит с помощью системного вызова write(1, "Hello, world!\n", 14Hello, world!) = 14
            записываем строку "Hello, world!\n" длиной 14 байт в файловый дескриптор 1 (консоль?) 
            Return value = 14 -> все 14 байт были успешно записаны

        +++ exited with 0 +++, in the last line states that exit status is 0 which means there was no error. 
            In case of an error, the exit code is -1.

        ? Че так много вызовов ?
        - The only actually necessary system calls for a Hello-World are write(stdout, "Hello World", 11) and exit(). 
        Any others are coming from the runtime library of the language you used for development, and are there to 
        support features used in more complex programs.



        ii
        Используйте сискол в программе hello world вместо printf(). 
        Убедитесь что этот вызов присутствует в выводе strace.

        https://man7.org/linux/man-pages/man2/write.2.html

        ssize_t write(int fd, const void buf[.count], size_t count);
        fd - file descriptor в который и будут записаны данные, у меня равен 1 - это стандартный вывод.
        buf - указатель на буфер с данными ("Hello, world!\n")
        count - количество байт для записи
        ! в случае успешной записи нам вернется 14 - число записанных байт 

        компиляция и запуск с strace новой программы: 
        gcc -o hello_write hello.c
        strace ./hello_write

        Да, действительно вывод присутствует в выводе trace: write(1, "Hello, world!\n", 14Hello, world!) = 14

        Разница между write() и printf(): https://stackoverflow.com/questions/21084218/difference-between-write-and-printf



        iii
        напишите свою обертку над этим сисколом. Для этого используйте функцию syscall() из libc. 
        Также проверьте вывод strace.

        компиляция и запуск с strace:
        gcc -o hello_syscall hello.c
        strace ./hello_syscall

        в выводе strace опять вижу write(1, "hello, world!\n", 14hello, world!) = 14 а значит вызвал write() 
            через syscall 

    b   Запустите под strace команду ‘wget kernel.org’ (если нет wget, используйте curl). 
        Получите статистику использования системных вызовов порожденным процессом.
    strace wget kernel.org

    вообще чтобы собрать статистику системных вызовов, можно сделать так: strace -c wget kernel.org

    wget - утилита для загрузки файлов из сети. В нашем случае она пытается загрузить содержимое с сайта 
    kernel.org, а при этом strace перехватывает и выводит все системные вызовы, 
    которые выполняются процессом wget

2 Разберитесь как устроена функция syscall(). Напишите код, который напечатает hello world без использования функции syscall().
    Разбор ассемблерных вставок:

    volatile чтобы предотвратить оптимизацию вставок компилятором
    In AT&T however registers are prefixed with a '%' and immed's are prefixed with a '$'.
    
    https://imada.sdu.dk/u/kslarsen/dm546/Material/IntelnATT.htm

    _start:
        movl    $write, %eax    // system call number (sys_write)
        movl    $1, %ebx        // file descriptor (stdout)
        lea     str, %ecx       // message to write
        movl    $len, %edx      // message length
        int     $0x80           // call kernel

        movl    $exit, %eax     // system call number (sys_exit)
        xorl    %ebx, %ebx 
        int     $0x80
    .data
    str:    .ascii "Hello, world!\n"
    len = . -str
    .globl  _start

    Скомпилируем программу: as -o hello.o hello.S - создан объектный файл hello.of
                            ld -o hellob hello.o - линковка объектного файла в executable файл

    https://www.tutorialspoint.com/assembly_programming/assembly_registers.htm
    https://stackoverflow.com/questions/1690893/hello-world-without-using-libraries



3. Разберитесь как работает системный вызов ptrace(2) и напишите программу, 
    которая породит процесс и выведет все системные вызовы дочернего процесса.

    как запускать: 
        gcc -o tracer ptrace.c && ./tracer ls -l
        gcc -o tracer ptrace.c && ./tracer echo "Hello World!"

    оговори шизоварик показывать сисколы по табличке отсюда: https://filippo.io/linux-syscall-table/

    struct user_regs_struct 
        структура данных, определённая в заголовках системы, которая 
            служит контейнером для всех основных регистров процессора в момент остановки 
            по ptrace(PTRACE_GETREGS)

        orig_rax хранит номер сискола, который собирается выполнить процесс, до того как ядро заменит rax на return value.
            При трассировке с PTRACE_SYSCALL процесс останавливается дважды на каждом syscall:
                1 ВХОД (syscall-enter) - в orig_rax лежит номер вызова, а в rax - то же самое
                2 ВЫХОД (syscall-exit) - ядро помещает в rax значение, возвращённое системным вызовом, 
                    а orig_rax остаётся без изменений и продолжает хранить исходный номер
        
        причина наличия именно двух этих полей в структуре user_regs_struct: https://stackoverflow.com/questions/6468896/why-is-orig-eax-provided-in-addition-to-eax

        rax is also the return value and PTRACE_SYSCALL gets called twice for some syscalls on entrance and exit. 
        orig_rax field preserves the original rax value on syscall entrance.

        картинка ОТКРЫТЬ: https://notes.eatonphil.com/2023-10-01-intercepting-and-modifying-linux-system-calls-with-ptrace.html


    fork()
        При вызове fork() возникают два полностью идентичных процесса. 
            Весь код после fork() выполняется дважды, как в процессе-потомке, так и в процессе-родителе.

        https://www.opennet.ru/docs/RUS/linux_parallel/node7.html

    ptrace 
        long ptrace(enum __ptrace_request request, pid_t pid, void * addr, void * data); 
            request - код системного вызова, который нужно выполнить в дочернем процессе
            pid - pid дочернего (трассируемого) процесса
            addr - указатель на данные, которые нужно передать в системный вызов в дочернем процессе
            data - указатель на данные, которые нужно передать в системный вызов в родительском процессе

        ptrace - это средство, позволяющее родительскому процессу наблюдать и контролировать протекание 
            другого процесса, просматривать и изменять его данные и регистры.

            Родительский процесс может начать трассировку, сначала вызвав функцию fork(2), а затем 
                получившийся дочерний процесс может выполнить PTRACE_TRACEME, за которым следует 
                выполнение exec(3).

        в моем случае:
            ptrace(PTRACE_TRACEME, 0, NULL, NULL)
            ptrace(PTRACE_SYSCALL, child, NULL, NULL)
            ptrace(PTRACE_GETREGS, child, NULL, &regs) 

        https://www.opennet.ru/man.shtml?topic=ptrace&category=2&russian=0

    PTRACE_TRACEME
        флаг сообщает ядру, что текущий процесс желает быть трассируемым своим родителем.

    PTRACE_SYSCALL 
        для продолжения исполнения трасируемого процесса (дочернего) до наступления точки входа или выхода из системного вызова.

        на каждый системный вызов приходится две остановки: 
            1 - до выполнения системного вызова (вход) 
            2 - сразу после его завершения (выход)

    PTRACE_GETREGS
        копирует общие регистры дочернего процесса в переменную data родительского

    execvp
        int execvp(char *name, char *argv[]);
            name - путь к исполняемому файлу
            argv - аргументы командной строки новой программы

        Функция exec() (execute) загружает и запускает другую программу. Таким образом, 
            новая программа полностью замещает текущий процесс. 

    waitpid()
        pid_t waitpid(pid_t pid, int *status, int options);  
            pid - pid дочернего процесса
            status - указатель на переменную, в которую сохранится статус дочернего процесса
            options - опции

        Функция waitpid приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс, 
            указанный в параметре pid, не завершит выполнение, или пока не появится сигнал, 
            который либо завершает текущий процесс либо требует вызвать функцию-обработчик. 
            Если status != NULL, то функции wait и waitpid сохраняют информацию о статусе в переменной, на которую указывает status.
            !!! Если указанный дочерний процесс к моменту вызова функции уже завершился (так называемый "зомби"), 
                то функция немедленно возвращается.
        статус проверяем макросом из мана:
            WIFEXITED(status) 
                не равно нулю, если дочерний процесс успешно завершился.
            WEXITSTATUS(status)
                возвращает восемь младших битов значения, которое вернул завершившийся дочерний процесс. 
                Эти биты могли быть установлены в аргументе функции exit() или в аргументе оператора return функции main(). 
                !!! Этот макрос можно использовать, только если WIFEXITED вернул ненулевое значение.
            WTERMSIG(status)
                возвращает номер сигнала, который привел к завершению дочернего процесса. 
                Этот макрос можно использовать, только если WIFSIGNALED вернул ненулевое значение.
            WIFSTOPPED
                истинное значение, если дочерний процесс, из-за которого функция вернула управление, в настоящий момент остановлен.

        в моем случае:
            waitpid(child, &status, 0);

        https://www.opennet.ru/man.shtml?topic=waitpid&category=2&russian=0



3.2. реализовать задание 3 для многопоточной программы с использованием ptrace
    как запускать:
        gcc -o potoks potoks.c 
        gcc -o tracer2 ptrace2.c && ./tracer2 

    логика программы:

    пояснения к potoks.c:
        с помощью pthread_create создал 2 потока работающих бесконечно и параллельно main потоку.
            Программа не завершается сама.



        pthread_create
            int pthread_create( pthread_t *thread,
                        const pthread_attr_t *attr,
                        void * (*start_routine)( void * ),
                        void *arg );
                thread - NULL или указатель на объект pthread_t, где функция может хранить идентификатор созданного потока.
                attr - Указатель на структуру pthread_attr_t, которая определяет атрибуты нового потока. 
                    Если attr равен NULL, то будут использоваться атрибуты по умолчанию (см. pthread_attr_init()).
                start_routine - указатель на функцию, которая будет выполняться в новом потоке.
                arg - аргумент потоковой функции start_routine

            создает новый поток с указанными в attr атрибутами в вызывающем процессе.

            в моем случае: 
                pthread_create(&t1, NULL, thread_func, &id1);

            https://help.kpda.ru/neutrino/2020/help/index.jsp?topic=%2Fru.kpda.doc.os_ru%2Fhtml%2Flibraries%2Flibc%2Fp%2Fpthread_create.html
            https://www.opennet.ru/man.shtml?topic=pthread_create&category=3&russian=2

    пояснения к ptrace2.c:
        в выводе я всегда буду видеть 3 потока: например TID 12012, 12013 и 12014 - это и есть потоки 
            из potoks.c MAIN thread, t1 и t2 соответственно. 
        Если посомтреть на вывод проги то там много write() и nanosleep() - это работают потоки potoks.c.

        родитель: 
            делает fork()
            (синхронизация) ждет с помощью waitpid execve() у ребенка при выполнени execl() для начала работы potoks.c
            ptrace(PTRACE_SETOPTIONS + PTRACE_O_TRACECLONE) - включил для child опцию автоматической трассировки новых потоков, создаваемых им через clone()
            while(1) {
                ptrace(PTRACE_SYSCALL, child, NULL, NULL) - приостановил исполнение трасируемого процесса (дочернего) до наступления точки входа или выхода из системного вызова
                waitpid(-1, &status, NULL) - ждать события у любого дочернего потока
                if (WIFEXITED(status)) { ... } - обработка завершения какого-то дочернего потока
                if (WIFSTOPPED(status)) { - обработка остановки какого-то дочернего потока
                    ловлю SIGTRAP - сигнал трассивровки, генерируемый ядром при:
                        1 входе/выходе из системного вызова
                        2 clone()-ом создан новый поток
                    ptrace(PTRACE_GETREGS, child, NULL, &regs) - получаю регистры остановленного потока
                    if (!in_syscall[regs.rax]) {...} - определение входа/выхода в сискол
                }
            }
            ptrace(PTRACE_SYSCALL, tid, NULL, NULL) - продолжаю исполнение потока tid до входа/выхода из системного вызова


            ptrace(PTRACE_SETOPTIONS, child, NULL, PTRACE_O_TRACECLONE)
                включил для child опцию автоматической трассировки новых потоков, создаваемых им через clone()
                
                PTRACE_SETOPTIONS - Set ptrace options from data (в моем случае PTRACE_O_TRACECLONE) (!вместо прежних)
                child - идентификатор процесса для которог оменяем опции трассировки
                PTRACE_O_TRACECLONE - трасс-ть новые потоки созданные через clone()
                    "при любом системном вызове clone() остановить child и автоматически присоединиться к созданному clone() потоку"

            ptrace(PTRACE_SYSCALL, child, NULL, NULL)
                продолжаем исполнение трасируемого процесса (дочернего) до наступления точки входа или выхода из системного вызова

                child - идентификатор процесса которому дана команда продолжить работу до ...

            waitpid(-1, &status, __WALL)
                -1 - ждать любого дочернего процесса или потока
                &status - указатель на переменную, куда waitpid запишет код остановки или завершения
                __WALL - waitpid реагирует на остановки всех потоков в группе процессов 
                    (созданных через clone), а не только на главный
                
                то есть трассируются: 
                    1 остановка на входе/выходе сискол (наследие PTRACE_SYSCALL)
                    2 процесс (или поток) получил любой сигнал
                    3 завершение (exit())

            ptrace(PTRACE_GETREGS, tid, NULL, &regs)
                копируем общие регистры трассируемого (дочернего) процесса в переменную regs родительского

            WSTOPSIG - вернет сигнал (int), вызвавший остановку процесса (дочернего)
                https://docs-python.ru/standart-library/modul-os-python/opredelenie-sostojanija-protsessa/#os.WSTOPSIG

            