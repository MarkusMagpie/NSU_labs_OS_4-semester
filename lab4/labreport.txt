1
    a
        Напишите программу, которая создает переменные и выводит их адреса:
            i. локальные в функции;
            ii. статические в функции;
            iii. константы в функции;
            iv. глобальные инициализированные;
            v. глобальные неинициализированные;
            vi. глобальные константы.

        %p Отображение аргумента в виде адреса в шестнадцатеричных цифрах.
        пример: https://www.scaler.com/topics/p-in-c/

        gcc prog_a.c -o a
        ./a

        Пример вывода: 
        i - адрес локальной переменной: 0x7ffec9391cd0
        ii - адрес статической переменной: 0x5d7bb31be014
        iii - адрес константной переменной: 0x7ffec9391cd4
        iv - адрес глобальной переменной: 0x5d7bb31be010
        v - адрес глобальной неинициализированной переменной: 0x5d7bb31be01c
        vi - адрес глобальной константы: 0x5d7bb31bc008

    b
        Сопоставьте адреса переменных с областями адресного пространства из
        соответствующего /proc/<pid>/maps. Объясните увиденное.

        Первым делом "модернизировал" программу чтобы она не завершалась после вывода 6 переменной, а ждала нажатия кнопки.
        Это сделано чтобы я успел посомтреть идентификатор процесса моей программы - PID 

        перед нажатием клавиши для завершения программы a открыть 2 терминал, найти PID процесса:
        pgrep a 
        ps aux | grep ./a

        подставить найденный PID в сьроку ниже:
        cat /proc/<pid>/maps

        вижу стек: 
            7ffec9373000-7ffec9395000 rw-p 00000000 00:00 0                          [stack]
            действительно, i и iii - локальные переменные local_var и local_const лежат на стеке + на одном фрейме
            i - адрес локальной переменной: 0x7ffec9391cd0
            iii - адрес константной переменной: 0x7ffec9391cd4

        5d7bb31be000-5d7bb31bf000 rw-p 00003000 103:08 1312493                   /home/sorokinm/Desktop/NSU_labs_OS_4semester/lab4/task1/a
            ii - адрес статической переменной: 0x5d7bb31be014 
            лежит в секции elf файла .data

        5d7bb31be000-5d7bb31bf000 rw-p 00003000 103:08 1312493                   /home/sorokinm/Desktop/NSU_labs_OS_4semester/lab4/task1/a
            iv - адрес глобальной переменной: 0x5d7bb31be010
            инициализированные глобальные переменные хранятся в секции .data

        5d7bb31be000-5d7bb31bf000 rw-p 00003000 103:08 1312493                   /home/sorokinm/Desktop/NSU_labs_OS_4semester/lab4/task1/a
            v - адрес глобальной неинициализированной переменной: 0x5d7bb31be01c
            неинициализированные глобальные переменные хранятся в секции .bss
        
        5d7bb31bc000-5d7bb31bd000 r--p 00002000 103:08 1312493                   /home/sorokinm/Desktop/NSU_labs_OS_4semester/lab4/task1/a
            vi - адрес глобальной константы: 0x5d7bb31bc008
            глобальные константы - секция .rodata (только для чтения).
            Подтверждение: права r--p (только чтение).

        куча/heap:
            5d7bd88eb000-5d7bd890c000 rw-p 00000000 00:00 0                          [heap]

        Итого: 
            7ffec... - стек
            5d7bb31be000-5d7bb31bf000 - .data/.bss
            5d7bb31bc000-5d7bb31bd000 - .rodata
            


    c

        i и iii (адреса локальных переменных local_var и local_const) находятся в области стека, высокий адреса памяти (типа 0x7fff...). 
            Факт что локальная переменная и константа располагаются рядом (ибо разница в 4 байта), 
            свидетельствует о том, что они выделены в одном стековом фрейме!

        iv и v (глобальные переменные global_initialized и global_uninitialized) расположены подряд в сегменте данных

        ii (статич перем static_var) объявлена внутри функции, хранятся в сегменте данных (.data). адрес не принадлежат стеку

        vi (глобальная конст global_const) в отдельном сегменте (.rodata) - адрес отличен от остальных перем

        -------------------------------------------------------------------------------------------

        Используя утилиту nm (или readelf) определите в каких секциях
        находятся выделенные переменные переменные.

        nm выводит символы объекта и их адреса (lab1)

        nm a выдает следующее:
        0000000000002008 R global_const
        0000000000004010 D global_initialized
        000000000000401c B global_uninitialized
        0000000000004014 d static_var.0

        https://sourceware.org/binutils/docs/binutils/nm.html

        R - сегмент только для чтения (.rodata)
        D - сегмент данных (.data)
        d - тоже секция .data, но символ имеет локальную видимость (static-связывание внутри объектного файла).
            - D обозначает глобальный символ в .data, НО static_var объявлена внутри функции с ключевым словом static, 
            что ограничивает её видимость текущим файлом.
            - суффикс .0 - добавлен на этапе компиляции к статическим переменным во избежание конфликтов имен при линковке
        B - сегмент bss (неинициализированные переменные тут)
        (инициализированные перем в .data, неинициализированные перем в .bss)

        ?   4.1 - почему static_var хранится в d а не в D
        -   static - между вызовами функций сохраняется значение. Как это сделать? все данные функции хранятся на стеке а мне надо сохранять между вызовами
            то есть не на стеке -> в другом месте - в дата (ибо дата изначально идет в executable).

            https://www.ibm.com/docs/hr/aix/7.1?topic=n-nm-command
                D - Global data symbol.
                d	Local data symbol.

            static_var.0 - компилятор помечает такие переменные как локальные символы, потому что их область видимости ограничена функцией/файлом.
            global_initialized - глобальная переменная, объявленная вне функций, а 
                глобальные переменные видны всей программе, поэтому их символы помечаются как глобальные 

            итого:  1) D - глобальный символ данных, те переменная имеет внешнее связывание <-> доступна за пределами файла
                    2) d - локальный символ данных, переменная имеет внутреннее связывание (видна только в этом объектном файле).
                            Эти символы не учасвтсвуют в линковке между модулями, в отличие от D.

        -   теперь про связывания: https://proglib.io/p/cpp-linking
            В единицу трансляции включены файл реализации (.c/.cpp) и все его заголовочные файлы (.h/.hpp). 
                Если внутри единицы трансляции у объекта или функции есть внутреннее связывание, то этот символ 
                    виден линкеру только внутри этой единицы трансляции. 
                Если же у объекта или функции есть внешнее связывание, то линкер сможет видеть его при обработке других единиц трансляции.

            Единица трансляции - исходный код, который компилятор обрабатывает как отдельный модуль для генерации объектного файла (.o). 
                Она формируется после обработки препроцессором и включает:
                    Исходный файл (.c, .cpp),
                    Все содержимое подключенных заголовочных файлов (через #include),
                    Результат макроподстановок (#define, #ifdef).
            препроцессор -> единица трансляции (нема директив предпроцессора и коментов) -> compiler -> .o object file -> linker -> executable

            ключевое слово static в глобальном пространстве имен дает символу внутреннее связывание. 
            extern - внешнее.

            Компилятор по умолчанию дает символам следующие связывания:
                Non-const глобальные переменные – внешнее связывание.
                Const глобальные переменные – внутреннее связывание.
                Функции – внешнее связывание.

        -   эксперимент в dop_a
            
            cd dop_a
            gcc file1.c file2.c -o test
            ./test
            nm test | grep -E 'global_var|static_var|local_static'

            global_var - глобальная переменная с внешним связыванием
                видна из других файлов через ключевое слово extern 

                extern keyword - used to declare a variable or a function whose definition is present in some other file. 
                It extends the visibility of the variables and functions in C to multiple source files.
                https://www.geeksforgeeks.org/understanding-extern-keyword-in-c/
                я фактически говорю компилятору - иди ищи инициализированную переменную в других файлах в пределах родительской директории 

            static_var - статическая переменная с внутренним связыванием
                не видна из других файлов (при попытке использовать extern int static_var ловлю ошибку линковки)
                Находится в секции .data, но с ограниченной видимостью

            local_static.0 - статическая переменная внутри функции func() в file1.c
                так как статик сохраняет значение между вызовами функции
                видима только внутри своей единицы трансляции

            и тут как-будто такая иерархия что вот есть локальный статик, есть глобальный а есть просто глобальная переменная. 
                Они все лежат в .data, но области видимости у них разные:
                    global_var - могу получать из других файлов через extern
                    static_vat - не могу но в файле она глобальная
                    local_static - статик в пределах одной функции



        ?   4.1 - зачем разделять bss и data
        -   bss это неинициализированные данные. 
            Пусть есть глоабльный массив на 1000 символов (много) - если записхать в .data и заполнить нулями, 
            то executable будет большим. При исполнении бинарного файла смотрится размер bss какой должен быть (в каком-то заголовке)
            и brk функция берет и выделяет память под bss. Все что хранится в .bss оно неинициализировано, но подразумевается значения нули.

            Чтобы подгрузить .bss нужно взять и выделить память. Не надо копировать, заполнять нулями и тд. 
            В executable массива bss нет, есть только его размер. То есть не раздуваем бинари. 
        
        -   оптимизация размера executable и процесса загрузки программы в память:
            .data - содержит инициализированные переменные, причем значения переменных хранятся в executable -> увеличивает его размер.
                При запуске программы данные из .data копируются из файла в оперативную память.
            .bss - неинициализированные переменные. В executable хранится только размер секции .bss, но не сами данные.
                При запуске программы командой brk или sbrk в Unix, ОС выделяет память под .bss и заполняет её нулями.

            покажи data_bss_test.c
            если переменная инициализирована нулями, то компилятор оптимизирует её размещение, отправив в .bss, чтобы не хранить нули в .data

            gcc data_bss_test.c -o data_bss
            readelf -S data_bss
            nm data_bss



        ? почему nm не показывает локальные переменные ?
        -   локальные на стеке, существуют только в пределах своей функции -> 
            они выделяются и уничтожаются во время вызова и завершения функции, 
            значит они не записываются в секции исполняемого файла, такие как .data и тд 

        более точные определения: https://gist.github.com/x0nu11byt3/bcb35c3de461e5fb66173071a2379779
        .bss: It contains uninitialized data (Type SHT_NOBITS). 
            It does not occupy space at disk to avoid space consuming, then all the data is usually initialized 
            to zero at runtime. It is writable.
        .data: Program initialized data, it is writable. (Type SHT_PROGBITS).
        .rodata: It is read-only data, such as strings used by the code, if the data should be writable then .data 
            is used instead. Data that goes here can be for example hardcoded strings used for a printf.

        с помощью команды readelf -S a можно подтвердить что данные переменные лежат в диапозоне секций (S - sections):
            нас интересует следующее: 
                [18] .rodata           PROGBITS         0000000000002000  00002000
                    00000000000001c5  0000000000000000   A       0     0     8
                адрес конца секции: 0x2000 + 0x1c5 = 0x21c5
                адрес global_const внутри диапозона секции .rodata
                (0000000000002000 < 0000000000002008 < 00000000000021c5)

                [25] .data             PROGBITS         0000000000004000  00003000
                    0000000000000018  0000000000000000  WA       0     0     8
                аналогично. адрес global_initialized внутри диапозона секции .data
                адрес конца секции: 0x4000 + 0x18 = 0x4018
                (0000000000004000 < 0000000000004010 < 0000000000004018)

                [26] .bss              NOBITS           0000000000004018  00003018
                    0000000000000008  0000000000000000  WA       0     0     4
                сравнив с адресом переменной global_uninitialized вижу что он лежит внутри диапозона секции .bss
                (0000000000004018 < 000000000000401c < 000000000000401f)

    d 
        Напишите функцию, которая создает и инициализирует локальную
        переменную и возвращает ее адрес. Прокомментируйте результат и
        дайте оценку происходящему.

        Написал prog_d.c

        gcc -o d prog_d.c
        ./d

        ? Почему изначально ловил segfault? 
        - create_local_variable создаёт локальную переменную local_var на стеке и возвращает её адрес. 
            Но по окончании выполнения функции область стека, в которой находилась переменная, будет освобождена и 
                возможно использоваться для других нужд.

        ? почему именно segfault ?
        -   ошибка сегментации (segfault) — ошибка программного обеспечения, возникающая при попытке обращения к недоступным 
                для записи участкам памяти либо при попытке изменить память запрещённым способом.
                https://ru.wikipedia.org/wiki/Ошибка_сегментации

            При вызове функций на верхушке стека создается stack frame. В него входит в том числе и возвратный адрес. 
                Когда завершается подпрограмма, мы по этому адресу и вернемся в место откуда вызывали подпрограмму.
                После этого стековый фрейм буквально удален и может быть использован для других нужд.
            В моем коде так как стекового фрейма уже нет, то указатель ptr ссылается на "висячий указатель".
                СПРАВКА: висячий указатель - указатель, который ссылается на область памяти, которая уже была освобождена.

            https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory#:~:text=Reading%20memory%20that%20has%20already,permissions%20of%20the%20vulnerable%20process.


        ? Как это исправить? 
        - динамической памятью с помощбю malloc, чтобы переменная продолжала существовать после выхода из функции

        тут почитай про память в СИ: https://craftofcoding.wordpress.com/2015/12/07/memory-in-c-the-stack-the-heap-and-static/

    e - f
        Напишите функцию, которая:
            i.
                выделяет на куче буфер (например, размером 100 байт);
            ii.
                записывает в него какую-либо фразу (например, hello world);
            iii.
                выводит содержимое буфера;
            iv.
                освобождает выделенную память;
            v.
                снова выводит содержимое буфера;
            vi.
                выделяет еще один буфер;
            vii.
                записывает в них какую-либо фразу (например, hello world);
            viii.
                выводит содержимое буфера;
            ix.
                перемещает указатель на середину буфера;
            x.
                освобождает память по этому указателю.
            xi.
                выводит содержимое буфера;

        ? почему в пункте v неопределенное поведение вывода буфера?
        - после вызова free (iv), указатель buffer больше не указывает на действительную память.
            Он теперь указывает на место которого нет -> "висячий"
            СПРАВКА: висячий указатель - указатель, который ссылается на область памяти, которая уже была освобождена
            Для исправления сделать: 
            buffer = NULL; // обнулить указатель, теперь он пустой -> pointer никуда не указывает (можно проверять с помощью (buffer == NULL))

        ? на x ловлю free(): invalid pointer Aborted (core dumped) ?
        - освобождаю память только с середины буфера -> не всю память освобождаю -> память, выделенная 
            изначально для buffer, остается неосвобожденной.

        ? почему в xi то же самое? 
        - написано выше 
            Как исправить? Делать не free(mid) а free(buffer)

        ?   как работает аллокация на куче ?
        -   ОТВЕТ: https://habr.com/ru/companies/otus/articles/889020/
        -   определение: 
                malloc(size_t size) - стандартная функция из stdlib.h, которая выделяет size байтов в хипе 
                    и возвращает указатель на начало блока.

            логика работы: 
                malloc(42) не выделит ровно 42 байта - система округлит размер до удобного для CPU значения (обычно 8 или 16 байт). 
                    Если в уже выделенной памяти есть подходящий свободный блок, то он будет использован.
                
                Если свободного блока нет, malloc() запрашивает новый блок памяти у ОС через 
                    sbrk() (для маленьких аллокаций - растягивает/двигает границу heap) 
                        void *sbrk(intptr_t increment);  
                        sbrk увеличивает пространство данных программы на increment байт. sbrk не является системным вызовом, он просто является обёрткой (wrapper), которую использует библиотека C
                        https://www.opennet.ru/man.shtml?topic=brk&category=2&russian=0

                    mmap() (для больших (>128KB) - выделяет страницы памяти напрямую)
                        void * mmap(void *start, size_t length, int prot , int flags, int fd, off_t offset);
                        mmap отражает length байтов, начиная со смещения offset файла (или другого объекта), определенного файловым описателем fd, в память, начиная с адреса start. 

                        https://www.opennet.ru/man.shtml?topic=mmap&category=2&russian=0
                ?   смысл такого разделения ?
                -   избегаем фрагментации хипа. ОС легче освободить такие блоки созданные mmap, чем sbrk()‑память.
                    также чатыее вызовы brk() дороги -> поэтому аллокатор резервирует память блоками.

                malloc() возвращает указатель на данные, но в памяти перед ним хранится метаинформация (размер блока, флаги и т. д.).
                то есть когда вы вызываете malloc(64), реально выделяется больше памяти:
                [ заголовок (16 байт) | мои запрошенные 64 байта ]

                ! Когда вы вызываете free(), malloc() ищет заголовок перед указателем, чтобы понять, сколько памяти освобождать. 
                    Именно поэтому нельзя free()‑ить указатели, которые не были получены через malloc().

            пример работы аллокации - ПОКАЖИ dop_malloc
                cd dop_malloc 

                    маленькая аллокация - test1.c 
                        gcc -o a test1.c
                        strace ./a

                        вижу в выводе следующее: 
                            brk(NULL) = 0x5609a66ad000
                            brk(0x5609a66ce000) = 0x5609a66ce000
                            
                            я вижу инициализацию начальной границы кучи
                            brk устанавливает новую границу кучи. То есть 0x5609a66ce000 это новый адрес конца кучи
                            СПРАВКА: sbrk(n) — увеличивает кучу на n байт (реализован через brk())
                            после free() блок помечен как свободный, но не возвращается в память ОС,    
                                он остается в куче для будущих malloc()-ов
                        
                        ? выше говорил про sbrk, а тут brk - почему ?
                        - sbrk() это обертка над brk() -> в strace, показывающий сисколу вижу сискол brk 
                    
                    большая аллокация - test2.c
                        gcc -o b test2.c
                        strace ./b

                        вижу в выводе следующее:
                            brk(NULL) = 0x5a5f680b7000
                            brk(0x60e7487cb000) = 0x60e7487cb000
                            mmap(NULL, 2101248, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x71cd34e00000 
                            
                            я вижу инициализацию начальной границы кучи
                            затем аллокатор вне сегмента кучи берет через mmap выделяет 2101248 байт (тк 2MB > 128RB)
                            позже в выводе видим munmap - память полностью освобождается (в отличие от brk(), где память остается в процессе)


        
    g - h - i
        g заведите переменную окружения.

        h. Добавьте в вашу программу код, который:
            i.
                распечатывает ее значение;
            ii.
                изменяет его значение;
            iii.
                повторно распечатывает ее значение.

        gcc prog_g.c -o g
        ./g

        Переменная среды - это переменная, значение которой установлено вне программы.

        Переменная окружения — это именованная величина, которая хранит данные, 
            доступные программам и процессам в операционной системе. 
            Эти переменные используются для настройки поведения приложений, 
            передачи параметров и управления средой выполнения.

        setenv
            Устанавливает или изменяет значение переменной окружения.
            
            int setenv(const char *name, const char *value, int overwrite);
            name - имя переменной окружения
            value - новое значение
            overwrite: 
                0 - не перезаписывать - переменная уже существует
                1 - перезаписать существующую

            https://man7.org/linux/man-pages/man3/setenv.3.html

        getenv
            возвращает указатель на информацию об окружении, ассоциированную со строкой name в таблице информации окружения
            Возвращает указатель на строку (значение переменной) или NULL, если переменной нет.

            https://www.c-cpp.ru/content/getenv

        ?   зачем нужны переменные окружения, где они физически находятся ?
        -   определение
            переменные окружения - способ хранения небольших фрагментов данных, 
                которые могут быть прочитаны процессами и приложениями в системе. 
                Это механизм для обмена данными между программами без необходимости записи в файлы или использования API.
            
            локация
            являются частью среды, в которой работает процесс. То есть физически хранятся в рамках адресного пр-ва процесса.

            пример: HOME указывает на домашнюю директорию пользователя, запустившего процесс (echo $HOME)
                    PATH - хранит набор путей к каталогам, которые указывают системе, где искать исполняемые файлы. 
                        Например,когда ввожу имя программы в терминале, система использует PATH для её поиска.
            
            смысл 
            чтобы программы могли адаптироваться к окружению, в котором запускаются без изменений в коде.
            типа "настройка по умолчанию" для разных программ в разных окружениях или для разных юзеров (у разных юзеров разный HOME)

            ! для динамической передачи параметров в процессы и программы во время их запуска. Примеры использования:
                настройка среды выполнения (PATH, LANG, ...)

            ? почему не использовать просто файлы для хранения данных вместо переменных окружения?
            -   1
                переменные окружения хранятся в оперативной памяти процесса, а значит доступ к ним - мгновенный! 
                А файлы требуют чтения (ввод и вывод) а это медленнее.

                2
                переменные окружения существуют только во время работы процесса
                файлы сохранены на диске

                3 - безопасность
                переменные окружения доступны только процессу и его дочерним
                файлы могут быть считаны и/или изменены другими программами без настроенных прав доступа (rwx)

        - ВАЖНОЕ СВОЙСТВО ИЗ ответа 28.3: каждый процесс имеет свою копию переменных окружения. то есть изменений в дочернем процессе не влияют на родительские!

        -   покажи dop_g
            
            cd dop_g
            gcc -o g test1.c && ./g
            echo $LANG

            а можно запускать со своей настройкой (терминал - родительский процесс)
            LANG=ru_RU.UTF-8 ./g
            LANG=en_US.UTF-8 ./g

        ответ + пример PATH: https://www.reddit.com/r/learnpython/comments/gysg3z/can_somebody_explain_to_me_why_exactly/
        примеры: https://en.wikipedia.org/wiki/Environment_variable 

            

    j - k
        echo $ENV_VAR

        вывод: пусто
        ? почему пусто если задавал значение ?
        -   каждый процесс в ОС (наша программа это тоже процесс) имеет собственную копию переменных окружения
            Изменения setenv() действуют только внутри текущего процесса и его дочерних процессов.

        ? как работать с переменной до/после завершения программы ?
        -   export ENV_VAR="Hello terminal!"

            sorokinm@sorokinm-CREFG-XX:~/Desktop/NSU_labs_OS_4semester/lab4/task1$ export ENV_VAR="Hello terminal!"
            sorokinm@sorokinm-CREFG-XX:~/Desktop/NSU_labs_OS_4semester/lab4/task1$ gcc -o g prog_g.c 
            sorokinm@sorokinm-CREFG-XX:~/Desktop/NSU_labs_OS_4semester/lab4/task1$ ./g 
            --------------------------------------
            начальное значение: Hello terminal!
            ! значение переменной изменено !
            новое значение: bbb
            -------------------------------------

        ?   почему если выводим echo $ENV_VAR в проге то выводится bbb, а если просто в терминале, то Hello terminal! ?
        -   system("echo $ENV_VAR"); создает дочерний процесс, который наследует изменённое окружение из родительского процесса.
            Терминал, из которого была запущена программа - родительский процесс. 

        Переменные окружения программы — временные, изолированы от родительских процессов!

        Команда export создает или изменяет переменные окружения, которые доступны для всех дочерних процессов, 
        запускаемых из текущей оболочки (shell).
        
        созданные без export - локальные и видны только в текущей оболочке, но не в её дочерних процессах.



2 
    a - b
        Напишите программу, которая:
            i. выводит pid процесса;
            ii. ждет одну секунду;
            iii. делает exec(2) самой себя;
            iv. выводит сообщение “Hello world”

        КАК ЗАПУСКАТЬ:
        1 терминал
            gcc prog_ab.c -o ab && ./ab
        2 терминал 
            cat /proc/<PID>/maps

        анализ кода: 
            char *args[] = {argv[0], "--no-exec", NULL};
            массив аргументов для execvp:
                argv[0] — имя программы
                "--no-exec" — флаг, чтобы избежать бесконечной рекурсии создания образов (можно показать как оно выглядит)
                NULL — обязательный элемент для завершения списка.

            execvp заменяет текущий процесс новым образом программы:
                1 аргумент - argv[0] - путь к исполняемому файлу
                2 аргумент - args - аргументы для новой программы
            после успешного выполнения execvp код программы прерывается, и управление передается новому образу
            про exexcvp подробей: https://www.ibm.com/docs/en/zos/3.1.0?topic=functions-exec

        Образ программы - представление программы в памяти во время её выполнения. 
            Включает все компоненты, необходимые для работы процесса: код, данные, стек, кучу и другие структуры. 
            под данными подразумеваю секции в которых и лежат данные (.text - код, .data - иниц. данные, .bss - неиниц. данные, )

        теперь анализ ID процесса:
            до выполнения exec (после 1 PID):
                Секции памяти соответствуют исходному образу программы

            после выполнения exec (когда выведено "Hello world"):
                процесс перезагрузил свой образ, поэтому:
                секции .text, .rodata, .data, .bss те же самые такие же
                стек и куча переинициализированы

            ? что делает exec ?
            -   exec заменяет текущий процесс новым образом программы, но PID остается прежним.
                Стек и куча создаются заново, их адреса меняются.
                https://man7.org/linux/man-pages/man3/exec.3.html

            ? почему execvp а не exec ?
            -   execvp: 
                    int execvp(const char *file, char *const argv[]);
                    поиск executable в PATH local varible, 
                    аргументы - массив строк char *args[]
                ответ: удобство(?)

            ? почему параметр важно давать 1 доп параметр в массив аргументов execvp ?
            -   argc с 1 на 2 меняет, чтобы условие if (argc == 1) стало ложным (и как раз потом выводится хелоу ворлд)   



    c
        Напишите программу, которая:
            i. выводит pid процесса;
            ii. ждет 10 секунд (подберите паузу чтобы успеть начать мониторить
                адресное пространство процесса, например, watch cat /proc/<pid>/maps);
            iii. напишите функцию, которая будет выделять на стеке массив
                (например, 4096 байт) и рекурсивно вызывать себя;
            iv. понаблюдайте как изменяется адресное пространство процесса (стек);
            v. напишите цикл, в котором на каждой итерации будет выделяться
                память на куче (подберите размер буфера сами). Используйте
                секундную паузу между итерациями.
            vi. понаблюдайте как изменится адресное пространство процесса (heap);
            vii. освободите занятую память.
            viii. присоедините к процессу еще один регион адресов размером в 10
                страниц (используйте mmap(2) с флагом ANONYMOUS).
            ix. понаблюдайте за адресным пространством.x.
                измените права доступа к созданному региону и проверьте какая
                будет реакция, если их нарушить:
                    1. запретите читать данные и попробуйте прочитать из региона.
                    2. запретите писать и попробуйте записать.
            xi. попробуйте перехватить сигнал SIGSEGV.
            xii. отсоедините страницы с 4 по 6 в созданном вами регионе.
            xiii. понаблюдайте за адресным пространством.

        Как запусккать: 
            1 терминал 
                gcc -o c prog_c.c 
                ./c
            2 терминал
                watch cat /proc/pid/maps

            i 
                int pid = getpid();
                printf("PID: %d\n", pid);

                получил идентификатор процесса для мониторинга через /proc/<pid>/maps

                getpid()
                    getpid возвращает идентификатор ID текущего процесса

                    https://www.opennet.ru/man.shtml?topic=getpid&category=2&russian=0

            ii 
                watch 
                    периодическое выполнение команд и отображение их вывода в реальном времени на весь экран

                    https://linux.die.net/man/1/watch
            
            iii - iv
                каждый вызов recursive_stack создает новый стековый фрейм с массивом stack_arr[4096]. 
                    Адреса массива stack_arr уменьшаются при углублении рекурсии (стек растет вниз)

                Пример вывода:   
                    7ffed85b4000-7ffed85d6000 rw-p 00000000 00:00 0                          [stack]

                    === iii эксперимент с рекурсивным использованием стека ===
                    глубина стека 0: 0x7ffed85d2560
                    глубина стека 1: 0x7ffed85d1530
                    глубина стека 2: 0x7ffed85d0500
                    глубина стека 3: 0x7ffed85cf4d0

                    0x7ffed85d2560 - 0x7ffed85d1530 = 0x1030
                    0x1030 из hex в dec: 0x1000 = 4096 + 0x30 = 48 = 4096 + 48 = 4144 байта
                    стековый фрейм получается 4144, где stack_arr занимает только 4096, выранивание должно быть 16-байтное

                    ? почему адреса уменьшаются ?
                    - stack_arr[PAGE_SIZE] лежат на стеке, а стек растет вниз
                    - у стека есть указатель SP - stack pointer - он при каждом новом рекурсивном вызове сдвигается вниз на 4096

            v - vi 
                пример вывода:
                    59da7d2d3000-59da7d2f4000 rw-p 00000000 00:00 0                          [heap]

                    === v эксперимент с кучей ===
                    Часть кучи 0: 0x59da7d2d36b0
                    Часть кучи 1: 0x59da7d2d46c0
                    Часть кучи 2: 0x59da7d2d56d0
                    Часть кучи 3: 0x59da7d2d66e0
                    Часть кучи 4: 0x59da7d2d76f0   

                    0x59da7d2d46c0 - 0x59da7d2d36b0 = 0x1010 = 4112 байт

                    malloc(PAGE_SIZE) выделяет эти блоки в куче 

            viii - ix присоедините к процессу еще один регион адресов размером в 10 страниц

                mmap(NULL, PAGELOCK_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS, -1, 0);
                    NULL                        адрес (ОС сама выберет(?))
                    PAGELOCK_SIZE               размер региона
                    PROT_READ|PROT_WRITE        права доступа (
                                                PROT_READ - данные можно читать, 
                                                PROT_WRITE - в эту область можно записывать информацию)
                    MAP_PRIVATE|MAP_ANONYMOUS   флаги (
                                                MAP_ANONYMOUS - Отображение не резервируется ни в каком файле; 
                                                MAP_PRIVATE - изменения не видны другим процессам)
                    -1                          файловый дескриптор (не используется)
                    0                           смещение
                определение: 
                    void * mmap(void *start, size_t length, int prot , int flags, int fd, off_t offset);
                    mmap отражает length байтов, начиная со смещения offset файла (или другого объекта), 
                        определенного файловым описателем fd, в память, начиная с адреса start. 
                        Последний параметр (адрес) необязателен, и обычно бывает равен 0. 
                        Настоящее местоположение отраженных данных возвращается самой функцией mmap
                    
                    https://www.opennet.ru/man.shtml?topic=mmap&category=2&russian=0

                ИТОГО: В maps появится новый регион вида 
                    79a382987000-79a382989000 rw-p 00000000 00:00 0

            x измените права доступа к созданному региону
                1 запретить читать
                    mprotect(mapped, PAGELOCK_SIZE, PROT_NONE);
                2 запретить писать
                    mprotect(mapped, PAGELOCK_SIZE, PROT_READ);

                первым делом регистрируем функцию segv_handler для перехвата сигнала SIGSEGV (нарушение доступа к памяти):
                    signal(SIGSEGV, segv_handler);

                    https://en.cppreference.com/w/c/program/signal

                mprotect
                    int mprotect(const void *addr, size_t len, int prot);
                    mprotect контролирует доступ к области памяти.

                    prot состоит из следующих побитно и логически сложенных значений:
                        PROT_NONE Доступ к памяти запрещен.
                        PROT_READ Данные в памяти можно читать.
                        PROT_WRITE В память можно записать информацию.
                    https://www.opennet.ru/man.shtml?topic=mprotect&category=2&russian=0

            xii 
                partial_addr - указатель на начало 4-й страницы
                munmap освобождает 3 страницы (4096 * 3 = 12,288 байт) начиная с 4-й (partial_addr)
                
                munmap
                    int munmap(void *start, size_t length);
                    Системный вызов munmap удаляет все отражения из заданной области памяти, 
                        после чего все ссылки на данную область будут вызывать ошибку 
                        "неправильное обращение к памяти" (invalid memory reference). 
                    
                    https://www.opennet.ru/man.shtml?topic=munmap&category=2&russian=0

                как понимаю освобожденные страницы больше не принадлежат процессу -> оно должно быть видно в maps

                отсюда вырвал предложение: https://linux.die.net/man/2/munmap
                    It is not an error if the indicated range does not contain any mapped pages.
                    Это про то как лучше освобождать.