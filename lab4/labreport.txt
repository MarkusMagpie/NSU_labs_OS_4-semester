1
    a
        Напишите программу, которая создает переменные и выводит их адреса:
            i. локальные в функции;
            ii. статические в функции;
            iii. константы в функции;
            iv. глобальные инициализированные;
            v. глобальные неинициализированные;
            vi. глобальные константы.

        %p Отображение аргумента в виде адреса в шестнадцатеричных цифрах.
        пример: https://www.scaler.com/topics/p-in-c/

        gcc prog_a.c -o a
        ./a

        Пример вывода: 
        i - адрес локальной переменной: 0x7ffec9391cd0
        ii - адрес статической переменной: 0x5d7bb31be014
        iii - адрес константной переменной: 0x7ffec9391cd4
        iv - адрес глобальной переменной: 0x5d7bb31be010
        v - адрес глобальной неинициализированной переменной: 0x5d7bb31be01c
        vi - адрес глобальной константы: 0x5d7bb31bc008

    b
        Сопоставьте адреса переменных с областями адресного пространства из
        соответствующего /proc/<pid>/maps. Объясните увиденное.

        Первым делом "модернизировал" программу чтобы она не завершалась после вывода 6 переменной, а ждала нажатия кнопки.
        Это сделано чтобы я успел посомтреть идентификатор процесса моей программы - PID 

        перед нажатием клавиши для завершения программы a открыть 2 терминал, найти PID процесса:
        pgrep a 
        ps aux | grep ./a

        подставить найденный PID в сьроку ниже:
        cat /proc/<pid>/maps

        вижу стек: 
            7ffec9373000-7ffec9395000 rw-p 00000000 00:00 0                          [stack]
            действительно, i и iii - локальные переменные local_var и local_const лежат на стеке + на одном фрейме
            i - адрес локальной переменной: 0x7ffec9391cd0
            iii - адрес константной переменной: 0x7ffec9391cd4

        5d7bb31be000-5d7bb31bf000 rw-p 00003000 103:08 1312493                   /home/sorokinm/Desktop/NSU_labs_OS_4semester/lab4/task1/a
            ii - адрес статической переменной: 0x5d7bb31be014 
            лежит в секции elf файла .data

        5d7bb31be000-5d7bb31bf000 rw-p 00003000 103:08 1312493                   /home/sorokinm/Desktop/NSU_labs_OS_4semester/lab4/task1/a
            iv - адрес глобальной переменной: 0x5d7bb31be010
            инициализированные глобальные переменные хранятся в секции .data

        5d7bb31be000-5d7bb31bf000 rw-p 00003000 103:08 1312493                   /home/sorokinm/Desktop/NSU_labs_OS_4semester/lab4/task1/a
            v - адрес глобальной неинициализированной переменной: 0x5d7bb31be01c
            неинициализированные глобальные переменные хранятся в секции .bss
        
        5d7bb31bc000-5d7bb31bd000 r--p 00002000 103:08 1312493                   /home/sorokinm/Desktop/NSU_labs_OS_4semester/lab4/task1/a
            vi - адрес глобальной константы: 0x5d7bb31bc008
            глобальные константы - секция .rodata (только для чтения).
            Подтверждение: права r--p (только чтение).

        куча/heap:
            5d7bd88eb000-5d7bd890c000 rw-p 00000000 00:00 0                          [heap]

        Итого: 
            7ffec... - стек
            5d7bb31be000-5d7bb31bf000 - .data/.bss
            5d7bb31bc000-5d7bb31bd000 - .rodata
            


    c

        i и iii (адреса локальных переменных local_var и local_const) находятся в области стека, высокий адреса памяти (типа 0x7fff...). 
            Факт что локальная переменная и константа располагаются рядом (ибо разница в 4 байта), 
            свидетельствует о том, что они выделены в одном стековом фрейме!

        iv и v (глобальные переменные global_initialized и global_uninitialized) расположены подряд в сегменте данных

        ii (статич перем static_var) объявлена внутри функции, хранятся в сегменте данных (.data). адрес не принадлежат стеку

        vi (глобальная конст global_const) в отдельном сегменте (.rodata) - адрес отличен от остальных перем

        -------------------------------------------------------------------------------------------

        Используя утилиту nm (или readelf) определите в каких секциях
        находятся выделенные переменные переменные.

        nm выводит символы объекта и их адреса (lab1)

        nm a выдает следующее:
        0000000000002008 R global_const
        0000000000004010 D global_initialized
        000000000000401c B global_uninitialized
        0000000000004014 d static_var.0

        https://sourceware.org/binutils/docs/binutils/nm.html

        R - сегмент только для чтения (.rodata)
        D - сегмент данных (.data)
        d - тоже секция .data, но символ имеет локальную видимость (static-связывание внутри объектного файла).
            - D обозначает глобальный символ в .data, НО static_var объявлена внутри функции с ключевым словом static, 
            что ограничивает её видимость текущим файлом.
            - суффикс .0 - добавлен на этапе компиляции к статическим переменным во избежание конфликтов имен при линковке
        B - сегмент bss (неинициализированные переменные тут)
        (инициализированные перем в .data, неинициализированные перем в .bss)

        ?   4.1 - почему static_var хранится в d а не в D
        -   static - между вызовами функций сохраняется значение. Как это сделать? все данные функции хранятся на стеке а мне надо сохранять между вызовами
            то есть не на стеке -> в другом месте - в дата (ибо дата изначально идет в executable)



        ?   4.1 - зачем разделять bss и data
        -   bss это неинициализированные данные. Пусть есть глоабльный массив на 1000 символов (много) - если записхать в дату и заполнить нулями 
            то executable будет большим. При исполнении бинарного файла смотрится размер bss какой должен быть (в каком-то заголовке)
            и brk функция берет и выделяет память под bss. Все что хранится в бсс оно неинициализировано, но подразумевается значения нули.

            Чтобы подгрузить бсс нужно взять и выделить память. Не надо копировать, заполнять нулями и тд. В самом бинаре массива bss нет, есть только
            его размер. То есть не раздуваем бинари. 

        ? почему nm не показывает локальные переменные ?
        -   локальные на стеке, существуют только в пределах своей функции -> 
            они выделяются и уничтожаются во время вызова и завершения функции, 
            значит они не записываются в секции исполняемого файла, такие как .data и тд 

        более точные определения: https://gist.github.com/x0nu11byt3/bcb35c3de461e5fb66173071a2379779
        .bss: It contains uninitialized data (Type SHT_NOBITS). 
            It does not occupy space at disk to avoid space consuming, then all the data is usually initialized 
            to zero at runtime. It is writable.
        .data: Program initialized data, it is writable. (Type SHT_PROGBITS).
        .rodata: It is read-only data, such as strings used by the code, if the data should be writable then .data 
            is used instead. Data that goes here can be for example hardcoded strings used for a printf.

        с помощью команды readelf -S a можно подтвердить что данные переменные лежат в диапозоне секций (S - sections):
            нас интересует следующее: 
                [18] .rodata           PROGBITS         0000000000002000  00002000
                    00000000000001c5  0000000000000000   A       0     0     8
                адрес конца секции: 0x2000 + 0x1c5 = 0x21c5
                адрес global_const внутри диапозона секции .rodata
                (0000000000002000 < 0000000000002008 < 00000000000021c5)

                [25] .data             PROGBITS         0000000000004000  00003000
                    0000000000000018  0000000000000000  WA       0     0     8
                аналогично. адрес global_initialized внутри диапозона секции .data
                адрес конца секции: 0x4000 + 0x18 = 0x4018
                (0000000000004000 < 0000000000004010 < 0000000000004018)

                [26] .bss              NOBITS           0000000000004018  00003018
                    0000000000000008  0000000000000000  WA       0     0     4
                сравнив с адресом переменной global_uninitialized вижу что он лежит внутри диапозона секции .bss
                (0000000000004018 < 000000000000401c < 000000000000401f)

    d 
        Напишите функцию, которая создает и инициализирует локальную
        переменную и возвращает ее адрес. Прокомментируйте результат и
        дайте оценку происходящему.

        Написал prog_d.c

        gcc -o d prog_d.c
        ./d

        ? Почему изначально ловил segfault? 
        - create_local_variable создаёт локальную переменную local_var на стеке и возвращает её адрес. 
            Но по окончании выполнения функции область стека, в которой находилась переменная, может быть перезаписана или освобождена.

        ? Как это исправить? 
        - динамической памятью с помощбю malloc, чтобы переменная продолжала существовать после выхода из функции

        тут почитай про память в СИ: https://craftofcoding.wordpress.com/2015/12/07/memory-in-c-the-stack-the-heap-and-static/

    e - f
        Напишите функцию, которая:
            i.
                выделяет на куче буфер (например, размером 100 байт);
            ii.
                записывает в него какую-либо фразу (например, hello world);
            iii.
                выводит содержимое буфера;
            iv.
                освобождает выделенную память;
            v.
                снова выводит содержимое буфера;
            vi.
                выделяет еще один буфер;
            vii.
                записывает в них какую-либо фразу (например, hello world);
            viii.
                выводит содержимое буфера;
            ix.
                перемещает указатель на середину буфера;
            x.
                освобождает память по этому указателю.
            xi.
                выводит содержимое буфера;

        ? почему в пункте v неопределенное поведение вывода буфера?
        - после вызова free (iv), указатель buffer больше не указывает на действительную память.
            Он теперь указывает на место которого нет -> "висячий"
            СПРАВКА: висячий указатель - указатель, который ссылается на область памяти, которая уже была освобождена
            Для исправления сделать: 
            buffer = NULL; // обнулить указатель, теперь он пустой -> pointer никуда не указывает (можно проверять с помощью (buffer == NULL))

        ? на x ловлю free(): invalid pointer Aborted (core dumped) ?
        - освобождаю память только с середины буфера -> не всю память освобождаю -> память, выделенная 
            изначально для buffer, остается неосвобожденной.

        ? почему в xi то же самое? 
        - написано выше 
            Как исправить? Делать не free(mid) а free(buffer)
        
    g - h - i
        g заведите переменную окружения.

        h. Добавьте в вашу программу код, который:
            i.
                распечатывает ее значение;
            ii.
                изменяет его значение;
            iii.
                повторно распечатывает ее значение.

        gcc prog_g.c -o g
        ./g

        Переменная среды - это переменная, значение которой установлено вне программы.

        Переменная окружения — это именованная величина, которая хранит данные, 
            доступные программам и процессам в операционной системе. 
            Эти переменные используются для настройки поведения приложений, 
            передачи параметров и управления средой выполнения.

        setenv
            Устанавливает или изменяет значение переменной окружения.
            
            int setenv(const char *name, const char *value, int overwrite);
            name - имя переменной окружения
            value - новое значение
            overwrite: 
                0 - не перезаписывать - переменная уже существует
                1 - перезаписать существующую

            https://man7.org/linux/man-pages/man3/setenv.3.html

        getenv
            возвращает указатель на информацию об окружении, ассоциированную со строкой name в таблице информации окружения
            Возвращает указатель на строку (значение переменной) или NULL, если переменной нет.

            https://www.c-cpp.ru/content/getenv

    j - k
        echo $ENV_VAR

        вывод: пусто
        ? почему пусто если задавал значение ?
        -   Каждый процесс в ОС (включая программу) имеет собственную копию переменных окружения.
            Изменения setenv() действуют только внутри текущего процесса и его дочерних процессов.

        ? как сохранить переменную после завершения программы ?
        -   export ENV_VAR="Hello terminal!"

            sorokinm@sorokinm-CREFG-XX:~/Desktop/NSU_labs_OS_4semester/lab4/task1$ export ENV_VAR="Hello terminal!"
            sorokinm@sorokinm-CREFG-XX:~/Desktop/NSU_labs_OS_4semester/lab4/task1$ gcc -o g prog_g.c 
            sorokinm@sorokinm-CREFG-XX:~/Desktop/NSU_labs_OS_4semester/lab4/task1$ ./g 
            --------------------------------------
            начальное значение: Hello terminal!
            ! значение переменной изменено !
            новое значение: bbb
            -------------------------------------

        Переменные окружения программы — временные, изолированы от родительских процессов!

        Команда export создает или изменяет переменные окружения, которые доступны для всех дочерних процессов, 
        запускаемых из текущей оболочки (shell).
        
        созданные без export - локальные и видны только в текущей оболочке, но не в её дочерних процессах.



2 
    a - b
        Напишите программу, которая:
            i. выводит pid процесса;
            ii. ждет одну секунду;
            iii. делает exec(2) самой себя;
            iv. выводит сообщение “Hello world”

        КАК ЗАПУСКАТЬ:
        1 терминал
            gcc prog_ab.c -o ab && ./ab
        2 терминал 
            cat /proc/<PID>/maps

        анализ кода: 
            char *args[] = {argv[0], "--no-exec", NULL};
            массив аргументов для execvp:
                argv[0] — имя программы
                "--no-exec" — флаг, чтобы избежать бесконечной рекурсии создания образов (можно показать как оно выглядит)
                NULL — обязательный элемент для завершения списка.

            execvp заменяет текущий процесс новым образом программы:
                1 аргумент - argv[0] - путь к исполняемому файлу
                2 аргумент - args - аргументы для новой программы
            после успешного выполнения execvp код программы прерывается, и управление передается новому образу

        Образ программы - представление программы в памяти во время её выполнения. 
            Включает все компоненты, необходимые для работы процесса: код, данные, стек, кучу и другие структуры. 
            под данными подразумеваю секции в которых и лежат данные (.text - код, .data - иниц. данные, .bss - неиниц. данные, )

        теперь анализ ID процесса:
            до выполнения exec (после 1 PID):
                Секции памяти соответствуют исходному образу программы

            после выполнения exec (когда выведено "Hello world"):
                процесс перезагрузил свой образ, поэтому:
                секции .text, .rodata, .data, .bss те же самые такие же
                стек и куча переинициализированы

            ? что делает exec ?
            -   exec заменяет текущий процесс новым образом программы, но PID остается прежним.
                Стек и куча создаются заново, их адреса меняются.
                https://man7.org/linux/man-pages/man3/exec.3.html

            ? почему execvp а не exec ?
            -   execvp: 
                    поиск executable в PATH local varible, 
                    аргументы - массив строк char *args[]
                exec: 
                    нужно полный путь к executable указывать
                    аргументы - отдельные параметры
                ответ: удобство(?)

            ? почему параметр важно давать 1 доп параметр в массив аргументов execvp ?
            -   argc с 1 на 2 меняет, чтобы условие if (argc == 1) стало ложным (и как раз потом выводится хелоу ворлд)                