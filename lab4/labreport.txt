1
    a
        Напишите программу, которая создает переменные и выводит их адреса:
            i. локальные в функции;
            ii. статические в функции;
            iii. константы в функции;
            iv. глобальные инициализированные;
            v. глобальные неинициализированные;
            vi. глобальные константы.

        %p Отображение аргумента в виде адреса в шестнадцатеричных цифрах.
        пример: https://www.scaler.com/topics/p-in-c/

        gcc prog_a.c -o a
        ./a

    b
        Сопоставьте адреса переменных с областями адресного пространства из
        соответствующего /proc/<pid>/maps. Объясните увиденное.

        i и iii (адреса локальных переменных local_var и local_const) находятся в области стека, высокий адреса памяти (типа 0x7fff...). 
            Факт что локальная переменная и константа располагаются рядом (ибо разница в 4 байта), 
            свидетельствует о том, что они выделены в одном стековом фрейме!

        iv и v (глобальные переменные global_initialized и global_uninitialized) расположены подряд в сегменте данных

        ii (статич перем static_var) объявлена внутри функции, хранятся в сегменте данных (.data). адрес не принадлежат стеку

        vi (глобальная конст global_const) в отдельном сегменте (.rodata) - адрес отличен от остальных перем

    c
        Используя утилиту nm (или readelf) определите в каких секциях
        находятся выделенные переменные переменные.

        nm выводит символы объекта и их адреса (lab1)

        nm a выдает следующее:
        0000000000002008 R global_const
        0000000000004010 D global_initialized
        000000000000401c B global_uninitialized

        R - сегмент только для чтения (.rodata)
        D - сегмент данных (.data)
        B - сегмент bss (неинициализированные переменные тут)
        (инициализированные перем в .data, неинициализированные перем в .bss)

        ? почему nm не показывает локальные переменные ?
        -   локальные на стеке, существуют только в пределах своей функции -> 
            они выделяются и уничтожаются во время вызова и завершения функции, 
            значит они не записываются в секции исполняемого файла, такие как .data и тд 

        более точные определения: https://gist.github.com/x0nu11byt3/bcb35c3de461e5fb66173071a2379779
        .bss: It contains uninitialized data (Type SHT_NOBITS). 
            It does not occupy space at disk to avoid space consuming, then all the data is usually initialized 
            to zero at runtime. It is writable.
        .data: Program initialized data, it is writable. (Type SHT_PROGBITS).
        .rodata: It is read-only data, such as strings used by the code, if the data should be writable then .data 
            is used instead. Data that goes here can be for example hardcoded strings used for a printf.

        с помощью команды readelf -S a можно подтвердить что данные переменные лежат в диапозоне секций (S - sections):
            нас интересует следующее: 
                [18] .rodata           PROGBITS         0000000000002000  00002000
                    00000000000001c5  0000000000000000   A       0     0     8
                адрес конца секции: 0x2000 + 0x1c5 = 0x21c5
                адрес global_const внутри диапозона секции .rodata
                (0000000000002000 < 0000000000002008 < 00000000000021c5)

                [25] .data             PROGBITS         0000000000004000  00003000
                    0000000000000018  0000000000000000  WA       0     0     8
                аналогично. адрес global_initialized внутри диапозона секции .data
                адрес конца секции: 0x4000 + 0x18 = 0x4018
                (0000000000004000 < 0000000000004010 < 0000000000004018)

                [26] .bss              NOBITS           0000000000004018  00003018
                    0000000000000008  0000000000000000  WA       0     0     4
                сравнив с адресом переменной global_uninitialized вижу что он лежит внутри диапозона секции .bss
                (0000000000004018 < 000000000000401c < 000000000000401f)

    d 
        Напишите функцию, которая создает и инициализирует локальную
        переменную и возвращает ее адрес. Прокомментируйте результат и
        дайте оценку происходящему.

        Написал prog_d.c

        gcc -o d prog_d.c
        ./d

        ? Почему изначально ловил segfault? 
        - create_local_variable создаёт локальную переменную local_var на стеке и возвращает её адрес. 
            Но по окончании выполнения функции область стека, в которой находилась переменная, может быть перезаписана или освобождена.

        ? Как это исправить? 
        - динамической памятью с помощбю malloc, чтобы переменная продолжала существовать после выхода из функции

        тут почитай про память в СИ: https://craftofcoding.wordpress.com/2015/12/07/memory-in-c-the-stack-the-heap-and-static/

    e - f
        Напишите функцию, которая:
            i.
                выделяет на куче буфер (например, размером 100 байт);
            ii.
                записывает в него какую-либо фразу (например, hello world);
            iii.
                выводит содержимое буфера;
            iv.
                освобождает выделенную память;
            v.
                снова выводит содержимое буфера;
            vi.
                выделяет еще один буфер;
            vii.
                записывает в них какую-либо фразу (например, hello world);
            viii.
                выводит содержимое буфера;
            ix.
                перемещает указатель на середину буфера;
            x.
                освобождает память по этому указателю.
            xi.
                выводит содержимое буфера;

        ? почему в пункте v неопределенное поведение вывода буфера?
        - после вызова free (iv), указатель buffer больше не указывает на действительную память.
            Он теперь указывает на место которого нет -> "висячий"
            Для исправления сделать: 
            buffer = NULL; // установить указатель в нал чтобы он не был висячим

        ? на x ловлю free(): invalid pointer Aborted (core dumped) ?
        - освобождаю память только с середины буфера -> не всю память освобождаю -> память, выделенная 
            изначально для buffer, остается неосвобожденной.

        ? почему в xi то же самое? 
        - написано выше 
            Как исправить? Делать не free(mid) а free(buffer)
        
    g - h - i
        g заведите переменную окружения.

        h. Добавьте в вашу программу код, который:
            i.
                распечатывает ее значение;
            ii.
                изменяет его значение;
            iii.
                повторно распечатывает ее значение.

        Переменная среды - это переменная, значение которой установлено вне программы.
        
        Переменная окружения — это именованная величина, которая хранит данные, 
            доступные программам и процессам в операционной системе. 
            Эти переменные используются для настройки поведения приложений, 
            передачи параметров и управления средой выполнения.

        setenv
            Устанавливает или изменяет значение переменной окружения.
            
            int setenv(const char *name, const char *value, int overwrite);
            name - имя переменной окружения
            value - новое значение
            overwrite: 
                0 - не перезаписывать - переменная уже существует
                1 - перезаписать существующую

        getenv
            возвращает указатель на информацию об окружении, ассоциированную со строкой name в таблице информации окружения
            Возвращает указатель на строку (значение переменной) или NULL, если переменной нет.

            https://www.c-cpp.ru/content/getenv