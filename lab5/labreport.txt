1
    a-b
        Напишите программу, которая:
            i. создает и инициализирует переменную (можно две: локальную и глобальную);
            ii. выводит ее (их) адрес(а) и содержимое;
            iii. выводит pid;
            iv. порождает новый процесс (используйте fork(2)).
            v. в дочернем процессе выводит pid и parent pid.
            vi. в дочернем процессе выводит адреса и содержимое переменных, созданных в пункте а;
            vii. в дочернем процессе изменяет содержимое переменных и выводит их значение;
            viii. в родительском процессе выводит содержимое переменных;
            ix. в родительском процессе делает sleep(30);
            x. в дочернем процессе завершается с кодом “5” (exit(2)).
            xi. в родительском процессе дожидается завершения дочернего, 
                вычитывает код завершения 
                выводит причину завершения и код завершения если он есть. 
                В каком случае кода завершения не будет?

        gcc -o res process.c  && ./res

        используемые функции:
        iii getpid()
            getpid возвращает идентификатор ID текущего процесса. 

            https://www.opennet.ru/man.shtml?topic=getpid&category=2&russian=0
        iv fork()
            При вызове fork() возникают два полностью идентичных процесса. 
                Весь код после fork() выполняется дважды, как в процессе-потомке, так и в процессе-родителе.

            https://www.opennet.ru/docs/RUS/linux_parallel/node7.html
        v getppid()
            getppid возвращает идентификатор ID родительского процесса.  

            https://www.opennet.ru/man.shtml?topic=getpid&category=2&russian=0
        x exit()
            void exit(int status)

            exit() вызывает немедленное нормальное завершение программы. 
                Значение параметра status задается вызывающим процессом. 
                По соглашению, если значением параметра status является 0, то предполагается нормальное завершение программы. 
                Ненулевое значение используется для указания ошибки, зависящей от реализации. 
            в моем случае родительскому процессу PID будет возвращен код 5
            ? как я это понял ?
            - его и получает родительский процесс через waitpid() и затем выводит WEXITSTATUS(status)
            
            https://www.c-cpp.ru/content/exit-exit
        xi waitpid()
            pid_t waitpid(pid_t pid, int *status, int options);  
            Функция waitpid приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс, 
                указанный в параметре pid, не завершит выполнение, или пока не появится сигнал, 
                который либо завершает текущий процесс либо требует вызвать функцию-обработчик. 
                Если status != NULL, то функции wait и waitpid сохраняют информацию о статусе в переменной, на которую указывает status.
                !!! Если указанный дочерний процесс к моменту вызова функции уже завершился (так называемый "зомби"), 
                    то функция немедленно возвращается.
            статус проверяем макросом из мана:
                WIFEXITED(status) 
                    не равно нулю, если дочерний процесс успешно завершился.
                WEXITSTATUS(status)
                    возвращает восемь младших битов значения, которое вернул завершившийся дочерний процесс. 
                    Эти биты могли быть установлены в аргументе функции exit() или в аргументе оператора return функции main(). 
                    !!! Этот макрос можно использовать, только если WIFEXITED вернул ненулевое значение.
                WTERMSIG(status)
                    возвращает номер сигнала, который привел к завершению дочернего процесса. 
                    Этот макрос можно использовать, только если WIFSIGNALED вернул ненулевое значение.


            https://www.opennet.ru/man.shtml?topic=waitpid&category=2&russian=0

    c-d
        Понаблюдайте за адресными пространствами/состояниями процесса в procfs.

        просмотр через nm
            1 терминал
                gcc -o res process.c  && ./res
            2 терминал 
                cat /proc/<PID>/maps
            3 терминал
                nm res | grep -E 'global_var|local_var'

        в 3 терминале вывелась только 
            0000000000004010 D global_var

        ? почему nm не показывает локальные переменные ?
        -   локальные на стеке, существуют только в пределах своей функции -> 
            они выделяются и уничтожаются во время вызова и завершения функции, 
            значит они не записываются в секции исполняемого файла, такие как .data и тд 

        с помощью команды readelf -S a можно подтвердить что данные переменные лежат в диапозоне секций (S - sections):
            [25] .data             PROGBITS         0000000000004000  00003000
            0000000000000014  0000000000000000  WA       0     0     8
            адрес конца секции: 0x4000 + 0x14 = 0x4014
            адрес global_var внутри диапозона секции .data
            (0000000000004000 < 0000000000004010 < 0000000000004014)

        просмотр через procfs:  
            1 терминал
                gcc -o res process.c  && ./res
            2 терминал 
                cat /proc/PPID/status | grep State
            3 терминал 
                cat /proc/CPID/status | grep State

            родительский статус: State:  S (sleeping)
            дочерний статус: State:  Z (zombie)

            во время sleep(30) родитель находится в состоянии прерываемого сна S
            дочерний процесс завершился сразу после exit(5) (НО информация о нем: PID, статус завершения сохранены в "таблице процессов"), 
                а родительский ждет 30 секунд до waitpid().
                И пока родитель спит, дочерний процесс завершенный, остается в статусе зомби (Z), так как родитель еще не обработал его статус.
                Когда выполнится waitpid(), информация о дочернем процессе будет удалена и дочерний процесс полностью удален.

            про таблицу процессов: https://stackoverflow.com/questions/4880555/what-is-the-linux-process-table-what-does-it-consist-of



2   
    a
        Модифицируйте предыдущую программу так чтобы дочерний процесс становился зомби.

        отличия от таска 1:
            убран вызов waitpid() в родительском процессе
            родительский процесс после сна сразу завершается, не ждет дочерний
    
        1 терминал
            cd ../task2 
            gcc -o zmb zombie_child.c && ./zmb
        2 терминал 
            cat /proc/PPID/status | grep State
        3 терминал 
            cat /proc/CPID/status | grep State

        If a parent creates a child, but fails to perform a wait(), then an entry for the zombie child 
            will be maintained indefinitely in the kernel’s process table. 
        ответ: https://stackoverflow.com/questions/74923603/are-zombie-processes-picked-up-by-init-eventually-or-not


    
    b
        Объясните какую проблему решает данное состояние.

        само состояние zombie нужно чтобы родительский процесс мог получить статус завершения дочернего процесса.
        код выхода (в 1 таске это 5) хранится в "таблице процессов" до тех пор, пока родитель не прочитает её через waitpid(). 
            А значит родитель всегда сможет узнать, как завершился его ребенок  



    c 
        Может ли родительский процесс оказаться в состоянии зомби? Если да, 
        то что в этом случае произойдет с дочерним? Смоделируйте эту 
        ситуацию.

        может, если его собственный родитель (shell) не вызвал waitpid() для него 

        пример: 
            родительский создает дочерний и сразу завершается
            дочерний процесс продолжает работать (спит) - у него потерян родитель - назначается новый
            родитель - зомби, пока его родитель (shell) не обработает его статус

        1 терминал
            gcc -o zmb2 zombie_parent.c && ./zmb2
        2 терминал - смотрю родителя
            cat /proc/PPID/status | grep State
            ps -p PPID
        3 терминал 
            cat /proc/CPID/status | grep State
            ps -p CPID -o pid,ppid,stat,comm

        что происходит:
            1 - через пару секунд после запуска родитель - зомби 
            2 - через 30 секунд дочерний процесс завершится
            3 - PPID дочернего процесса изменится на 1 (init) после завершения родителя
                init запускается первым при загрузке системы и управляет всеми процессами. он же периодически "усыновляет" wait-ом
                    зомби-процессы, оставшиеся после родителей.

                https://wiki.archlinux.org/title/Init#:~:text=Init%20is%20the%20direct%20or,typically%20assigned%20process%20identifier%201.

                direct or indirect ancestor of all other processes, and automatically adopts all orphaned processes. 
                    It is started by the kernel using a hard-coded filename;

                зомби-сироты по появленю заполняют kernel process table и логично что их надо оттуда убирать с помощью wait(). Это и делает init.

        подборка orphan процесса init-ом:
            If a parent process terminates, then its "zombie" children (if any) are adopted by init(8), 
                which automatically performs a wait to remove the zombies.
            https://stackoverflow.com/questions/24346126/where-do-zombie-processes-go-after-their-parent-dies