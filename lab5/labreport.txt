1
    a-b
        Напишите программу, которая:
            i. создает и инициализирует переменную (можно две: локальную и глобальную);
            ii. выводит ее (их) адрес(а) и содержимое;
            iii. выводит pid;
            iv. порождает новый процесс (используйте fork(2)).
            v. в дочернем процессе выводит pid и parent pid.
            vi. в дочернем процессе выводит адреса и содержимое переменных, созданных в пункте а;
            vii. в дочернем процессе изменяет содержимое переменных и выводит их значение;
            viii. в родительском процессе выводит содержимое переменных;
            ix. в родительском процессе делает sleep(30);
            x. в дочернем процессе завершается с кодом “5” (exit(2)).
            xi. в родительском процессе дожидается завершения дочернего, 
                вычитывает код завершения 
                выводит причину завершения и код завершения если он есть. 
                В каком случае кода завершения не будет?

        gcc -o res process.c  && ./res

        используемые функции:
        iii getpid()
            getpid возвращает идентификатор ID текущего процесса. 

            https://www.opennet.ru/man.shtml?topic=getpid&category=2&russian=0
        iv fork()
            При вызове fork() возникают два полностью идентичных процесса. 
                Весь код после fork() выполняется дважды, как в процессе-потомке, так и в процессе-родителе.

            https://www.opennet.ru/docs/RUS/linux_parallel/node7.html
        v getppid()
            getppid возвращает идентификатор ID родительского процесса.  

            https://www.opennet.ru/man.shtml?topic=getpid&category=2&russian=0
        x exit()
            void exit(int status)

            exit() вызывает немедленное нормальное завершение программы. 
                Значение параметра status задается вызывающим процессом. 
                По соглашению, если значением параметра status является 0, то предполагается нормальное завершение программы. 
                Ненулевое значение используется для указания ошибки, зависящей от реализации. 
            в моем случае родительскому процессу PID будет возвращен код 5
            ? как я это понял ?
            - его и получает родительский процесс через waitpid() и затем выводит WEXITSTATUS(status)
            
            https://www.c-cpp.ru/content/exit-exit
        xi waitpid()
            pid_t waitpid(pid_t pid, int *status, int options);  
            Функция waitpid приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс, 
                указанный в параметре pid, не завершит выполнение, или пока не появится сигнал, 
                который либо завершает текущий процесс либо требует вызвать функцию-обработчик. 
                Если status != NULL, то функции wait и waitpid сохраняют информацию о статусе в переменной, на которую указывает status.
                !!! Если указанный дочерний процесс к моменту вызова функции уже завершился (так называемый "зомби"), 
                    то функция немедленно возвращается.
            статус проверяем макросом из мана:
                WIFEXITED(status) 
                    не равно нулю, если дочерний процесс успешно завершился.
                WEXITSTATUS(status)
                    возвращает восемь младших битов значения, которое вернул завершившийся дочерний процесс. 
                    Эти биты могли быть установлены в аргументе функции exit() или в аргументе оператора return функции main(). 
                    !!! Этот макрос можно использовать, только если WIFEXITED вернул ненулевое значение.
                WTERMSIG(status)
                    возвращает номер сигнала, который привел к завершению дочернего процесса. 
                    Этот макрос можно использовать, только если WIFSIGNALED вернул ненулевое значение.


            https://www.opennet.ru/man.shtml?topic=waitpid&category=2&russian=0

    c 
        Понаблюдайте за адресными пространствами в procfs.

        просмотр через nm
            1 терминал
                gcc -o res process.c  && ./res
            2 терминал 
                cat /proc/<PID>/maps
            3 терминал
                nm res | grep -E 'global_var|local_var'

        в 3 терминале вывелась только 
            0000000000004010 D global_var

        ? почему nm не показывает локальные переменные ?
        -   локальные на стеке, существуют только в пределах своей функции -> 
            они выделяются и уничтожаются во время вызова и завершения функции, 
            значит они не записываются в секции исполняемого файла, такие как .data и тд 

        с помощью команды readelf -S a можно подтвердить что данные переменные лежат в диапозоне секций (S - sections):
            [25] .data             PROGBITS         0000000000004000  00003000
            0000000000000014  0000000000000000  WA       0     0     8
            адрес конца секции: 0x4000 + 0x14 = 0x4014
            адрес global_var внутри диапозона секции .data
            (0000000000004000 < 0000000000004010 < 0000000000004014)

        просмотр через procfs:  
            1 терминал
                gcc -o res process.c  && ./res
            2 терминал 
                cat /proc/PPID/status | grep State
            3 терминал 
                cat /proc/CPID/status | grep State

            родительский статус: State:  S (sleeping)
            дочерний статус: State:  Z (zombie)

            во время sleep(30) родитель находится в состоянии прерываемого сна S
            дочерний процесс завершился сразу после exit(5) (НО информация о нем: PID, статус завершения сохранены), 
                а родительский ждет 30 секунд до waitpid().
                И пока родитель спит, дочерний процесс завершенный, остается в статусе зомби (Z), так как родитель еще не обработал его статус.
                Когда выполнится waitpid(), информация о дочернем процессе будет удалена и дочерний процесс полностью удален.



    d 
        Понаблюдайте за состояниями процесса в procfs или с помощью утилиты ps.

        1 терминал
            gcc -o res process.c  && ./res
        2 терминал
            ps aux | grep -E 'PID|<PPID>|<CPID>'



2
