1
    a-b
        Напишите программу, которая:
            i. создает и инициализирует переменную (можно две: локальную и глобальную);
            ii. выводит ее (их) адрес(а) и содержимое;
            iii. выводит pid;
            iv. порождает новый процесс (используйте fork(2)).
            v. в дочернем процессе выводит pid и parent pid.
            vi. в дочернем процессе выводит адреса и содержимое переменных, созданных в пункте а;
            vii. в дочернем процессе изменяет содержимое переменных и выводит их значение;
            viii. в родительском процессе выводит содержимое переменных;
            ix. в родительском процессе делает sleep(30);
            x. в дочернем процессе завершается с кодом “5” (exit(2)).
            xi. в родительском процессе дожидается завершения дочернего, 
                вычитывает код завершения 
                выводит причину завершения и код завершения если он есть. 
                В каком случае кода завершения не будет?

        gcc -o res process.c  && ./res

        используемые функции:
        iii getpid()
            getpid возвращает идентификатор ID текущего процесса. 

            https://www.opennet.ru/man.shtml?topic=getpid&category=2&russian=0
        iv fork()
            При вызове fork() возникают два полностью идентичных процесса. 
                Весь код после fork() выполняется дважды, как в процессе-потомке, так и в процессе-родителе.

            https://www.opennet.ru/docs/RUS/linux_parallel/node7.html
        v getppid()
            getppid возвращает идентификатор ID родительского процесса.  

            https://www.opennet.ru/man.shtml?topic=getpid&category=2&russian=0
        x exit()
            void exit(int status)

            exit() вызывает немедленное нормальное завершение программы. 
                Значение параметра status задается вызывающим процессом. 
                По соглашению, если значением параметра status является 0, то предполагается нормальное завершение программы. 
                Ненулевое значение используется для указания ошибки, зависящей от реализации. 
            в моем случае родительскому процессу PID будет возвращен код 5
            ? как я это понял ?
            - его и получает родительский процесс через waitpid() и затем выводит WEXITSTATUS(status)
            
            https://www.c-cpp.ru/content/exit-exit
        xi waitpid()
            pid_t waitpid(pid_t pid, int *status, int options);  
            Функция waitpid приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс, 
                указанный в параметре pid, не завершит выполнение, или пока не появится сигнал, 
                который либо завершает текущий процесс либо требует вызвать функцию-обработчик. 
                Если status != NULL, то функции wait и waitpid сохраняют информацию о статусе в переменной, на которую указывает status.
                !!! Если указанный дочерний процесс к моменту вызова функции уже завершился (так называемый "зомби"), 
                    то функция немедленно возвращается.
            статус проверяем макросом из мана:
                WIFEXITED(status) 
                    не равно нулю, если дочерний процесс успешно завершился.
                WEXITSTATUS(status)
                    возвращает восемь младших битов значения, которое вернул завершившийся дочерний процесс. 
                    Эти биты могли быть установлены в аргументе функции exit() или в аргументе оператора return функции main(). 
                    !!! Этот макрос можно использовать, только если WIFEXITED вернул ненулевое значение.
                WTERMSIG(status)
                    возвращает номер сигнала, который привел к завершению дочернего процесса. 
                    Этот макрос можно использовать, только если WIFSIGNALED вернул ненулевое значение.


            https://www.opennet.ru/man.shtml?topic=waitpid&category=2&russian=0

    c-d
        Понаблюдайте за адресными пространствами/состояниями процесса в procfs.

        просмотр через nm
            1 терминал
                gcc -o res process.c  && ./res
            2 терминал 
                cat /proc/<PID>/maps
            3 терминал
                nm res | grep -E 'global_var|local_var'

        в 3 терминале вывелась только 
            0000000000004010 D global_var

        ? почему nm не показывает локальные переменные ?
        -   локальные на стеке, существуют только в пределах своей функции -> 
            они выделяются и уничтожаются во время вызова и завершения функции, 
            значит они не записываются в секции исполняемого файла, такие как .data и тд 

        с помощью команды readelf -S a можно подтвердить что данные переменные лежат в диапозоне секций (S - sections):
            [25] .data             PROGBITS         0000000000004000  00003000
            0000000000000014  0000000000000000  WA       0     0     8
            адрес конца секции: 0x4000 + 0x14 = 0x4014
            адрес global_var внутри диапозона секции .data
            (0000000000004000 < 0000000000004010 < 0000000000004014)

        просмотр через procfs:  
            1 терминал
                gcc -o res process.c  && ./res
            2 терминал 
                cat /proc/PPID/status | grep State
            3 терминал 
                cat /proc/CPID/status | grep State

            родительский статус: State:  S (sleeping)
            дочерний статус: State:  Z (zombie)

            во время sleep(30) родитель находится в состоянии прерываемого сна S
            дочерний процесс завершился сразу после exit(5) (НО информация о нем: PID, статус завершения сохранены в "таблице процессов"), 
                а родительский ждет 30 секунд до waitpid().
                И пока родитель спит, дочерний процесс завершенный, остается в статусе зомби (Z), так как родитель еще не обработал его статус.
                Когда выполнится waitpid(), информация о дочернем процессе будет удалена и дочерний процесс полностью удален.

            про таблицу процессов: https://stackoverflow.com/questions/4880555/what-is-the-linux-process-table-what-does-it-consist-of

        ?   зачем нужен Zombie статус ?
        -   если дочерний процесс завершился до того, как родитель вызвал для него wait()?
            ОС не может просто отбросить информацию о дочернем процессе так как 
                работа родительского процесса может зависеть от знаний exit статуса дочернего процесса.
                Пример:     1 The parent process might need to know that the child exited abnormally, 
                            2 it might be collecting CPU usage statistics for its children, etc. 
                поэтому единственным выходом является сохранение этой информации и предоставление её родителю, когда он наконец вызовет wait()
            Процессы-зомби позволяют гарантированно получить родителем: 
                1 статус выхода, 
                2 информацию о потреблении ресурсов 
                3 PID дочерних процессов 
                вне зависимости от того, вызвал ли родитель wait() до или после завершения дочернего процесса
        - механизм работы: 
            1 при завершении процесса через exit() ядро его помечает: terminated и оставляет запись в таблице процессов, 
                отправляя сигнал SIGCHLD родителю 
            2 парент получил SIGCHLD и должен вызвать wait() или waitpid() чтобы получить информацию о статусе выхода и учётные данные; 
                после этого ОС удалит запись зомби из таблицы 
            3 если парент игнорирует SIGCHLD ИЛИ устанавливает флаг SA_NOCLDWAIT то статус выхода сразу отбрасывается и зомби не создаются
            
            ответ: https://stackoverflow.com/questions/16416793/why-is-a-zombie-process-necessary
            про механизм работы: https://en.wikipedia.org/wiki/Zombie_process
        так как Process table (PT) состоит из PCB процессов то лучше ОТКРЫТЬ ПЕРЕД ОТВЕТОМ: https://www.geeksforgeeks.org/process-table-and-process-control-block-pcb/
        


        ?   чем программа отличается от процесса ? 
        -   Программа - это набор инструкций, записанных в файл для выполнения определённой задачи(task), но сама не выполняется до запуска.
            Процесс - экземпляр программы в исполнении, загруженный в оперативную память и выполняющий инструкции на CPU.
                существует только ограниченное вермя в отличии от программы.
                каждый процесс имеет свое виртуальное адресное простарнство: 
                    https://en.wikipedia.org/wiki/Virtual_address_space
                    https://stackoverflow.com/questions/69616280/does-each-process-have-its-own-virtual-address-space-when-running-in-parallel
            
            ?   почему нет смысла использовать nm res для получения адресов в процессе?
            -   nm res утилита анализирует ELF файл который статичен и показывает оффсеты символов в нем 
                    но это не реальные виртуальные адреса, под которыми сегменты загружаются в процесс.
            -   при nm res я смотрю на местоположение символов внутри бинарного файла. 
                а после exec файла proc/PID/maps покажет измененное адресное пространство процесса  в связи с 
                    ASLR (адреса выбираются случайным образом при старте процесса).
                
                Процесс - динамический экземпляр программы загружает её в свое виртуальное адресное пространство, 
                    и реальные адреса переменных определяются ОС для процесса, а не статически прописаны в файле. 
            -   nm res выводит оффсеты символов внутри ELF-файла (секции .text, .data, .bss), 
                    но это НЕ реальные виртуальные адреса при запуске.
                    При старте процесса ОС случайным образом смещает базовые адреса сегментов (код, данные, стек, heap) для безопасности.
                    Чтобы увидеть реальные адреса: /proc/<PID>/maps - это снимок текущего отображения памяти процесса
            
            ответы: https://www.tutorialspoint.com/difference-between-program-and-process

            ОБЯЗАТЕЛЬНО ОТКРЫТЬ: https://www.baeldung.com/linux/proc-id-maps



2   
    a zombie_child.c
        Модифицируйте предыдущую программу так чтобы дочерний процесс становился зомби.

        отличия от таска 1:
            родительский процесс после сна сразу завершается (нет wait()), не ждет дочерний
    
        1 терминал
            cd ../task2 
            gcc -o zmb zombie_child.c && ./zmb
        2 терминал 
            cat /proc/PPID/status | grep State
        3 терминал 
            cat /proc/CPID/status | grep State

        If a parent creates a child, but fails to perform a wait(), then an entry for the zombie child 
            will be maintained indefinitely in the kernel’s process table. 
        ответ: https://stackoverflow.com/questions/74923603/are-zombie-processes-picked-up-by-init-eventually-or-not


    
    b
        Объясните какую проблему решает данное состояние. - мой доп к первой части - можно не говорить

        само состояние zombie нужно чтобы родительский процесс мог получить статус завершения дочернего процесса.
        код выхода (в 1 таске это 5) хранится в "таблице процессов" до тех пор, пока родитель не прочитает её через waitpid(). 
            А значит родитель всегда сможет узнать, как завершился его ребенок  



    c zombie_parent.c
        Может ли родительский процесс оказаться в состоянии зомби? Если да, 
        то что в этом случае произойдет с дочерним? Смоделируйте эту 
        ситуацию.

        может, если он завершился, а его собственный родитель (shell-оболочка) не вызвал wait() для него 
        тогда: 
            дочерние процессы родительского зомби становятся сиротами
            они автоматически усыновляются процессом init (PID 1)
                init периодически вызывает wait(), чтобы собрать статусы сирот, предотвращая их превращение в зомби
                про init: https://wiki.archlinux.org/title/Init#:~:text=Init%20is%20the%20direct%20or,typically%20assigned%20process%20identifier%201

        1 терминал
            gcc -o zmb2 zombie_parent.c && ./zmb2

        что происходит:
            0 - запускаю А, он создает B
            0 - B создает C
            0-10 - B спит (a mimir)
            10 - B завершается - становится зомби
            10-15 - А спит, B остается зомби
            15 - А завершается, B-зомби-сирота, init вызывает wait() для B и B исчезает из списка процессов
            20 - C завершается, init вызывает wait() для C и C исчезает из списка процессов (ВАЖНО: видно что pid=1)
        
        ?   почему C выводит сообщение в терминал, где был запущен родительский процесс A?
        -   дочерние процессы наследуют файловые дескрипторы родителя, 
                включая стандартный вывод stdout. 
                После завершения процесса A, C пишет в тот же терминал, так как он унаследовал stdout от A.
            ТЕРМИНАЛ != РОДИТЕЛЬСКИЙ ПРОЦЕСС
        
        ?   почему PPID C = 1, а не PID оболочки?
        -   А завершается -> B зомби
            B завершается -> C ребенок-сирота
            init (PID=1) автоматически становится новым родителем для C 

        идеальный ответ: информация о процессе C выводится в терминал, так как C унаследовал стандартный вывод 
            (stdout) от процесса A. После завершения A и B, процесс C становится сиротой и усыновляется init-ом, 
            НО продолжает писать в тот же терминал, так как его stdout не был перенаправлен. 
            Это не противоречит тому, что его родителем теперь является init - вывод в терминал и родительский 
            процесс это разные вещи.

        СПРАВКА: Когда программа открывает файл, она запрашивает у операционной системы доступ к нему. 
            В ответ ОС выделяет файловый дескриптор, который программа использует для выполнения операций с этим файлом.
            пример: 
                int fd = open("example.txt", O_RDONLY); // Открытие файла только для чтения
                if (fd == -1) {
                    return 1;
                }
            https://ru.hexlet.io/blog/posts/faylovyy-deskriptor-chto-eto-prostymi-slovami#:~:text=Файловый%20дескриптор%20(file%20descriptor)%20—,хотя%20используются%20и%20в%20Windows.
        
        посмотреть файловые дескрипторы процесса:
            ls -l /proc/PID/fd
        

        подборка orphan процесса init-ом:
            If a parent process terminates, then its "zombie" children (if any) are adopted by init(8), 
                which automatically performs a wait to remove the zombies.
            https://stackoverflow.com/questions/24346126/where-do-zombie-processes-go-after-their-parent-dies
            the orphan process is soon adopted by init process, once its parent process dies.
            https://www.geeksforgeeks.org/zombie-and-orphan-processes-in-c/



3 
    a. Используйте системный вызов clone(2) для создания процесса:
        i.
            Память для стека выделите при помощи mmap(2), таким образом,
            чтобы новый регион был связан с файлом и синхронизировался с
            ним при изменении. Т.е. при записи в новый регион, данные
            должны синхронизироваться с файлом.
        ii.
            Напишите две функции:
                1. Первая - точка входа для нового процесса.
                2. Вторая функция должна выделять на стеке массив со
                строкой “hello world” и рекурсивно вызывать себя. Глубина
                рекурсии пусть будет равна 10.
        iii.
            Вызовите вторую функцию из функции нового процесса и после
            ее исполнения завершите новый процесс.
    b. Исследуйте полученный файл:
        i.
            найдите строки “hello world”. Сколько их и почему столько?
        ii.
            найдите переменную счетчик, которая используется для
            ограничения рекурсии.
        iii.
            найдите адреса возврата из функций.

    как запускать: 
        gcc -o clone clone_proc.c && ./clone
        xxd stackfile.dat

        xxd - hexdump файла. Для каждой группы байт пишу(по 16): смещение, шестнадцатеричные значения байтов, их ASCII представление

    a.
        open
            int open(const char *pathname, int flags, mode_t mode)
                pathname - указатель на путь к файлу который нужно открыть
                flags - битовая маска, задающая режим доступа и поведение при открытии
                mode - права доступа к файлу

            в моем случае:
                open(file_path, O_RDWR | O_CREAT, 0666)
                    O_RDWR - открыть для чтения и записи
                    O_CREAT - создать если еще не существует

                    mode задает права доступа, которые используются в случае создания нового файла.
                        в моем случае: 0666 - чтение и запись для всех пользователей

            https://www.opennet.ru/man.shtml?topic=open&category=2

        ftruncate
            int truncate(const char *path, off_t length)
                устанавливает длину обычного файла с именем path в length байт.
                При использовании ftruncate файл должен быть открыт для записи.

            в моем случае: 
                ftruncate(fd, STACK_SIZE)

            https://www.opennet.ru/man.shtml?topic=ftruncate&category=2&russian=0

        mmap
            void * mmap(void *start, size_t length, int prot , int flags, int fd, off_t offset);
                mmap отражает length байтов, начиная со смещения offset файла (или другого объекта), 
                    определенного файловым описателем fd, в память, начиная с адреса start. 
                    Последний параметр (адрес) необязателен, и обычно бывает равен 0. 
                    Настоящее местоположение отраженных данных возвращается самой функцией mmap

            в моем случае: 
                mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)
                    NULL                        адрес
                    STACK_SIZE                  размер региона
                    PROT_READ|PROT_WRITE        права доступа:
                                                PROT_READ - данные можно читать, 
                                                PROT_WRITE - можно записывать информацию
                    MAP_SHARED                  все записи в отображённой области будут записаны 
                                                    обратно в файл и видны другим процессам, где 
                                                    открыт тот же fd
                    fd                          файловый дескриптор
                    0                           смещение

            https://www.opennet.ru/man.shtml?topic=mmap&category=2&russian=0

        munmap
            int munmap(void *start, size_t length);
                Системный вызов munmap удаляет все отражения из заданной области памяти, 
                    после чего все ссылки на данную область будут вызывать ошибку 
                    "неправильное обращение к памяти" (invalid memory reference). 
                
            https://www.opennet.ru/man.shtml?topic=munmap&category=2&russian=0

        clone
            int clone(int (*fn)(void *), void *child_stack, int flags, void *arg)
                создаёт новый процесс как и fork(2). В отличие от fork(2), позволяет процессу-ребенку 
                    разделять части их контекста выполнения с процессом-родителем: такие как область 
                    памяти, таблицу файловых дескрипторов и таблицу обработчиков сигналов. 

            в моем случае: 
                clone(child_entry, child_stack, SIGCHLD, NULL)
                    child_entry - функция которая будет исполнена в новом процессе
                    child_stack - указатель на стек нового процесса
                    SIGCHLD - сигнал который будет отправлен родителю после завершения дочернего процесса
                    NULL - аргумент функции child_entry

            https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=clone&category=2

            ! clone() vs fork() 
                1 кастомная точка входа дочернего процесса - fn с аргументом arg.
                    Новый процесс начинает исполнение именно с функции fn, а не с 
                        точки системного вызова, как при fork()
                2 указываю кастомную область памяти под стек ребенка - child_stack
                3 когда fn(arg) завершится (возвратит управление), дочерний процесс 
                    завершится с кодом возврата, равным возвращённому значению fn, 
                    либо может завершить работу явно через exit() или после 
                    фатального сигнала.
                    (у fork() сигнал возвращения - всегда SIGCHLD)

                подробнее здесь: https://stackoverflow.com/questions/4856255/the-difference-between-fork-vfork-exec-and-clone

        _exit()
            вызывает немедленное нормальное завершение программы, НО не вызываем пользовательские функции очистки,
                буфферизованные данные остаются в текущем состоянии - к ним не применяется fflush() для очистки
            https://www.c-cpp.ru/content/exit-exit

    b. 
        "hello world\0" расположено по оффсетам: 0x0d70, 0x0db0, 0x0df0, 0x0e30, 0x0e70, 0x0eb0, 0x0ef0, 0x0f30, 0x0f70, 0x0fb0
            всего 10 копий - соответствует глубине рекурсии. Разница между оффсетами - 0x40 - 64 байта.
            Столько компилятор резервирует под один стек-фрейм. 
        