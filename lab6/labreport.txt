1
    a. Создайте регион памяти размером в одну страницу при помощи 
    системного вызова mmap(2), таким образом, чтобы он был общим для 
    двух процессов.
    b. Пусть один процесс непрерывно пишет целые числа (типа unsigned int) 
    от 0 до максимального значения (0, 1, ... max) в данный регион. Когда он 
    доходит до конца региона, сразу начинает писать сначала.
    c. Другой процесс читает из этого региона и проверяет, что числа идут 
    последовательно. При обнаружении сбоя последовательности, выводит 
    соответствующее сообщение в консоль.
    d. Объясните причину таких сбоев.
    e. Как вы думаете, что можно было бы сделать чтобы этих сбоев не было?

    a-c
        gcc -o mem shared_memory.c && ./mem

        mmap
            void *mmap(void *start, size_t length, int prot , int flags, int fd, off_t offset);
            
            mmap отражает length байтов, начиная со смещения offset файла (или другого объекта), 
                определенного файловым описателем fd, в память, начиная с адреса start. 

                В моем случае должен быть создан регион памяти ОБЩИЙ для 2 процессов. Как мы это достигаем?
                mmap(NULL,                          начальный адрес для выделения памяти определяется ядром
                    PAGE_SIZE,                      запрашиваю регон памяти размером в 1 страницу
                    PROT_READ | PROT_WRITE,         память доступна и для чтения и для записи
                    MAP_SHARED | MAP_ANONYMOUS,     MAP_SHARED - изменения в памяти видны всем процессам которые используют этот регион
                                                    MAP_ANONYMOUS - память не связана с файлом, fd и offset - игнорируются
                    -1,                             игнорируется - для анонимной памяти не требуется дескриптор
                    0                               игнорируется - смещение в файле (причина выше на 2 строки) 
                )

            https://www.opennet.ru/man.shtml?topic=mmap&category=2&russian=0

        exit()
            void exit(int status)

            exit() вызывает немедленное нормальное завершение программы. 
                Значение параметра status задается вызывающим процессом. 
                По соглашению, если значением параметра status является 0, то предполагается нормальное завершение программы. 
                Ненулевое значение используется для указания ошибки, зависящей от реализации. 

            https://www.c-cpp.ru/books/exit

        ПРИМЕР РАБОТЫ:
            sorokinm@sorokinm-CREFG-XX:~/Desktop/NSU_labs_OS_4semester/lab6/task1$ gcc -o mem shared_memory.c && ./mem
            получил 0 по индексу 0
            получил 1 по индексу 1
            получил 2 по индексу 2
            ошибка: ожидал 3, получил 1027 по индексу 3

    d 
        сбои возникают из-за асинхронной работы процессов (результат гонки процессов - race condition).
            Читатель может прочитать ячейку до того, как писатель её обновит.

        ?   что происходит под капотом?
        -   
            в writer-e переписываются ячейки:
                shared[0] = 0;
                shared[1] = 1;
                shared[2] = 2;
                ...
                shared[1023] = 1023;
                shared[0] = 1024; // заново
                shared[1] = 1025;

            в reader-e чтение происходит ГОРАЗДО медленнее:
                read(shared[0]) = 0 - успел прочесть сразу
                ... тут вывод успеха или сон 
                read(shared[1]) = дохренилион  - потому что writer уже многократно перезаписал shared[1]

            

2
    Взаимодействие процессов через pipe:
    a. Аналогично предыдущей задаче, организуйте передачу
    последовательности целых чисел (unsigned int) через pipe.
    b. Объясните почему при передаче через pipe не наблюдаются проблемы,
    которые возникали при передаче через разделяемую память.

    a
        pipe
            Функция pipe создает канал между двумя процессами и возвращает два дескриптора файла. 
                Дескриптор 0 открывается для чтения. Дескриптор 1 открывается для записи. 
                Операция чтения получает данные в порядке их записи. 
                Описанные дескрипторы файлов применяются функциями read, write.

            https://www.ibm.com/docs/ru/aix/7.1?topic=p-pipe-subroutine

    b почему в pipe нет проблем с гонками данных?
        операции ввода и вывода (read write)выполняются в коде ядра. Ядро последовательно обрабатывает вызовы write() и read(), 
            блокируя их и разблокируя в порядке поступления, 
            что исключает состояние гонки даже при значительной разнице в скоростях процессов. 
        Можно сказать что нет общей памяти которую можно испортить общим доступом.

        Данные, записанные в pipe, помещаются в кольцевой буфер "pipe buffer" внутри ядра Linux и хранятся до тех пор, 
            пока процесс-читалка не извлечет их из буфера.
        https://blogs.oracle.com/linux/post/pipe-and-splice

        гарантирует атомарность каждого вызова write() для блоков данных не более PIPE_BUF (обычно 4 KiB), 
            что предотвращает «перемешивание» данных от нескольких писателей в пределах одного вызова 

        ответ на английском:
            In the POSIX systems, kernel uses internal mutexes, and locks the file descriptors for the pipe. 
                Then it allows the requesting thread to write. If any other thread requests write at this point, 
                then it would have to wait for the first thread. After that the file descriptors are unlocked, 
                so the other waiting threads can write to the pipe. So yes, kernel would not allow more than 
                one thread to write to the pipe at the same time.

            https://stackoverflow.com/questions/41149387/meaning-of-atomicity-of-posix-pipe-write
