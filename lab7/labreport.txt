1. UDP - эхо сервер:
    a. Сделайте UDP-сервер, который принимает данные от клиентов и пересылает их обратно клиенту.
    b. Напишите UDP-клиента, для теста UDP-сервера.
    c. Проверьте, что UDP-сервер, работает с несколькими клиентами.

    как запускать: 
        1 терминал
            g++ server.cpp -o server && ./server
        2 терминал
            g++ client.cpp -o client && ./client
        3 терминал
            g++ client.cpp -o client && ./client

        1 терминал
            gcc server.c -o server2 && ./server2
        2 терминал
            gcc client.c -o client2 && ./client2
        3 терминал
            gcc client.c -o client2 && ./client2

    struct sockaddr_in
        struct sockaddr_in {
            sa_family_t     sin_family;     /* AF_INET */
            in_port_t       sin_port;       /* Port number */
            struct in_addr  sin_addr;       /* IPv4 address */
        };

        в моем случае: 
            сервер: 
                server_addr.sin_family = AF_INET; // IP адрес к которому будет привязан сокет (IPv4)
                server_addr.sin_port = htons(PORT); // номер порта к которому будет привязан сокет
            клиент: 
                server_addr.sin_family = AF_INET;
                server_addr.sin_port = htons(PORT);

        Структура sockaddr_in описывает сокет для работы с протоколами IP. 
            Значение поля sin_family всегда равно AF_INET.
            Поле sin_port содержит номер порта который намерен занять процесс. 
                Если значение этого поля равно нулю, то операционная система сама выделит свободный номер порта для сокета. 
            Поле sin_addr типа структуры in_addr, содержит IP адрес к которому будет привязан сокет.
                Структура in_addr содержит поле s_addr. Этому полю можно присвоить 32х битное значение IP адреса. 

        https://www.opennet.ru/docs/RUS/socket/node4.html
        https://man7.org/linux/man-pages/man3/sockaddr.3type.html
        https://learn.microsoft.com/ru-ru/windows/win32/api/ws2def/ns-ws2def-sockaddr_in

    htons
        uint16_t htons(uint16_t hostshort);
        Функция htons() преобразует узловой порядок расположения байтов 
            положительного короткого целого hostshort в сетевой порядок расположения байтов.
        
        https://www.opennet.ru/man.shtml?topic=htons&category=3&russian=0

    socket
        int socket (int domain, int type, int protocol)
            domain - cпецификация семейства адресов
            type - cпецификация типа для нового сокета
            protocol - Используемый протокол. 
                Возможные параметры параметра протокола относятся к указанному семейству адресов и типу сокета. 

        в моем случае:
            socket(AF_INET, SOCK_DGRAM, 0)
                AF_INET - cемейство адресов IPv4 
                SOCK_DGRAM - тот тип сокета использует протокол UDP для семейства адресов Интернета. Посылаем ДАТАГРАМЫ 
                0 - вызывающий объект не хочет указывать протокол, и поставщик услуг выберет протокол для использования

        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock2/nf-winsock2-socket
        https://www.opennet.ru/docs/RUS/linux_base/node245.html

    bind
        int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
            sockfd - дескриптор, определяющий несвязанный сокет, ему мы функцией bind задаем адрес
            addr - указатель на структуру sockaddr локального адреса, назначаемого связанному сокету
            addrlen - длина (в байтах) значения, на которое указывает addr

        в моем случае: 
            bind(server_fd, (const struct sockaddr*)&server_addr, sizeof(server_addr))

        функция используется сервером для присваивания сокету имени. До выполнения функции bind (т.е. присваивания 
            какого-либо имени, вид которого зависит от адресного домена) сокет недоступен программам-клиентам.

        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock/nf-winsock-bind
        https://www.opennet.ru/docs/RUS/linux_base/node246.html

    sendto
        ssize_t sendto(int s, const void *msg, size_t len, int flags, const struct sockaddr *to, socklen_t tolen);
            s - Дескриптор, определяющий сокет
            msg - Указатель на буфер, содержащий передаваемые данные.
            len - Длина (в байтах) данных, на которые указывает параметр buf.
            flags - Набор флагов, указывающих способ вызова.
            to - Необязательный указатель на структуру sockaddr, содержащую адрес целевого сокета.
            tolen - Размер (в байтах) адреса, на который указывает параметр to.

        в моем случае:
            sendto(server_fd, buffer, msg_len, 0, (const struct sockaddr*)&client_addr, client_len)

        важно: параметр flags является битовой маской и может содержать такие флаги: 
            MSG_CONFIRM - Сообщает (на уровне связи), что процесс пересылки произошел: вы получаете успешный ответ с другой стороны.
            ...

        Функция sendto используется для записи исходящих данных в сокет. 

        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock2/nf-winsock2-sendto
        https://www.opennet.ru/man.shtml?topic=sendto&category=2&russian=0
    
    recvfrom
        int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);
            s - Дескриптор, определяющий привязанный сокет.
            buf - Буфер для входящих данных.
            len - Длина (в байтах) буфера, на который указывает параметр buf .
            flags - Набор параметров, которые изменяют поведение вызова функции за пределами параметров, указанных для связанного сокета. 
            from - Необязательный указатель на буфер в структуре sockaddr , который будет содержать исходный адрес при возврате.
            fromlen - Необязательный указатель на размер (в байтах) буфера, на который указывает параметр from.

        в моем случае:
            сервер: recvfrom(server_fd, buffer, BUFFER_SIZE, 0, (sockaddr*)&client_addr, &client_len)
            клиент: recvfrom(client_fd, buffer, BUFFER_SIZE, 0, NULL, NULL)
            ?   2 последних параметра у клиента NULL - что это значит?
            -   информация об отправителе сообщения не сохраняется на клиенте (ибо не нужна)

        Системный вызовы recvfrom используются для получения сообщений из сокета. Возвращает длину сообщения при успешном завершении.
        Аргумент flags системного вызова recv формируется с помощью объединения логической операцией ИЛИ 
            одного или более нижеследующих значений:
            MSG_WAITALL - просит подождать, пока не придет полное запрошенное количество данных.
            ...

        https://www.opennet.ru/man.shtml?topic=recvfrom&category=2&russian=0
        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock2/nf-winsock2-recvfrom

    inet_ntoa
        char *inet_ntoa(struct in_addr in);
        
        преобразует IP-адрес in, заданный в сетевом порядке расположения байтов, в стандартный строчный вид ASCII, завершающуюся NULL. 
            Строка располагается в статически размещенном буфере; последующие вызовы перепишут его данные.

        у меня используется для преобразования IPv4 адреса из бинарного формата (используется в сетевых структурах) 
            в читаемую строку в формате типа "192.168.1.1"

        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock2/nf-winsock2-inet_ntoa
        https://www.opennet.ru/man.shtml?topic=inet_ntoa&category=3&russian=0#:~:text=Функция%20inet_ntoa()%20преобразует%20IP,последующие%20вызовы%20перепишут%20его%20данные.

    inet_pton
        int inet_pton(int af, const char *src, void *dst);
            af - cпецификация семейства адресов (как в socket())
            src - указатель на строку, завершающуюся значением NULL, которая содержит текстовое 
                представление IP-адреса для преобразования в двоичную форму.
            dst - указатель на буфер, в котором будет храниться двоичное представление IP адреса. 
                IP адрес возвращается в порядке байтов сети.
        
        в моем случае: 
            inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr)
                AF_INET - cемейство адресов IPv4 
                "127.0.0.1" - преобразуемый IP адрес
                &server_addr.sin_addr - указатель на буфер, куда записать двоичное представление IP адреса

        Данная функция преобразует строку символов src в сетевой адрес (типа af), затем копирует полученную структуру с адресом в dst.
        По понятному: преобразует IP адрес из человекочитаемого строкового формата в бинарный, понятный сетевым функциям.

        https://www.opennet.ru/man.shtml?topic=inet_pton&category=3&russian=0
        https://learn.microsoft.com/ru-ru/windows/win32/api/ws2tcpip/nf-ws2tcpip-inet_pton

    ?   Что такое IP и порт?
    -   IP - числовой идентификатор хоста в сети, работающей по протоколу IP. Должен быть уникален для любого устройства в сети.
        СПРАВКА:    хост - устройство, объединяющее сеть.
                    IP (межсетевой протокол) - обеспечивает передачу данных без гарантии доставки.
        Порт - идентификатор программы или процесса, которые обслуживают сетевые соединения на заданном IP-адресе

        Представьте, что у вас дома 2 компьютера и они подключены к одному роутеру. Для всего интернета IP адрес этих 
            компьютеров одинаковый (так как внешний IP, который виден в интернете есть только у роутера). 
            В этом случае, чтобы обратиться к конкретному компьютеру, нужен порт. Например, на роутере настроено, 
            что у одного из компьютеров открыт порт 8245. Роутер имеет IP 95.84.208.79. Тогда обратиться к этому 
            компьютеру можно так: 95.84.208.79:8245
            
            IP адрес — это номер квартиры друга.
            Порт — это комната, в которой живёт друг

            https://qna.habr.com/q/844233#:~:text=Айпи-адрес%20-%20это%20адрес%20конкретного,конкретном%20компьютере%20шлется%20запрос%2C%20т.
            про порты: https://www.ittelo.ru/news/chto-takoe-port-v-seti/?srsltid=AfmBOorp-2zA1Mnurqtuc70K-Lrz_JDda0OzRAAma_09TCCyp9eXcH9W



2. ТСP - эхо сервер:
    a. Сделайте TCP-сервер, который принимает соединения от клиентов на заданном ip и port.
    b. создает новый процесс, в котором:
        i. читает данные от клиента;
        ii. пересылает их ему обратно.
    c. Напишите TCP-клиента для проверки TCP-сервера.
    d. Проверьте, что TCP-сервер работает с несколькими клиентами и обрабатывает сессии в разных процессах.

    как запускать: 
        1 терминал
            gcc server.c -o server && ./server
        2 терминал
            gcc client.c -o client && ./client
        3 терминал
            gcc client.c -o client && ./client

    сервер: 
        ЛОГИКА РАБОТЫ: 
            1 создаем и настраиваем TCP-сокет, байндим к порту
            2 listen() - ожидание запросов связи на сокете 
            3 while(1)
                accept() - принятие связи на сокет (новый клиент)
                печатаем ip и порт клиента 
                fork() - разделяемся: 
                    дочерний - закрывает server_fd, дальше в handle_client() читает данные, эхо-ответ, потом закрывает client_sock и exit(0)
                    родительский - закрывает client_sock(его обслуживает ребенок), возвращается к началу цикла - accept()

        socket
            int socket (int domain, int type, int protocol)
                domain - cпецификация семейства адресов
                type - cпецификация типа для нового сокета
                protocol - Используемый протокол. 
                    Возможные параметры параметра протокола относятся к указанному семейству адресов и типу сокета. 

            в моем случае:
                socket(AF_INET, SOCK_DGRAM, 0)
                    AF_INET - cемейство адресов IPv4 
                    SOCK_STREAM - тип сокета, который предоставляет виртуационные, надежные двусторонние потоки байтов на основе подключений 
                        с механизмом передачи данных OOB. Этот тип сокета использует протокол TCP  
                    0 - вызывающий объект не хочет указывать протокол, и поставщик услуг выберет протокол для использования

            https://learn.microsoft.com/ru-ru/windows/win32/api/winsock2/nf-winsock2-socket
            https://www.opennet.ru/docs/RUS/linux_base/node245.html

        listen
            int listen(int s, int backlog)
                s - сокет для прослушивания 
                backlog - целое положительное число, определяющее, как много запросов связи может быть принято на сокет одновременно.

            Функция listen используется сервером, чтобы информировать ОС, что он ожидает ("слушает") запросы связи на данном сокете. 
                Без такой функции всякое требование связи с этим сокетом будет отвергнуто.

            в моем случае: 
                listen(server_fd, 5)

            https://www.opennet.ru/docs/RUS/linux_base/node247.html#:~:text=Функция%20listen%20используется%20сервером%2C%20чтобы,int%20s%2C%20int%20backlog)%3B

        accept
            int accept(int s, char * name, int* anamelen)
                s - сокет-дескриптор для принятия связей от клиентов
                name - указатель на адрес клиента (структура sockaddr) для соответствующего домена
                anamelen - eказатель на целое число - длину структуры адреса

            Функция используется сервером для принятия связи на сокет. Сокет должен быть уже слушающим в момент вызова функции. 
                Если сервер устанавливает связь с клиентом, то функция accept возвращает новый сокет-дескриптор, 
                через который и происходит общение клиента с сервером.
            Если сервер не интересуется адресом клиента, в качестве второго и третьего аргументов можно задать NULL-указатели.

            в моем случае:
                accept(server_fd, (struct sockaddr*)&client_addr, &client_len)

            https://opennet.ru/docs/RUS/linux_base/node248.html#:~:text=Эта%20функция%20используется%20сервером%20для,происходит%20общение%20клиента%20с%20сервером.

        fork()
            При вызове fork() возникают два полностью идентичных процесса. 
                Весь код после fork() выполняется дважды, как в процессе-потомке, так и в процессе-родителе.

            https://www.opennet.ru/docs/RUS/linux_parallel/node7.html

        recv 
            int recv(int s, void *buf, size_t len, int flags)
                s - файловый дескриптор уже открытого и connected сокета 
                buf - указатель на начало буфера в памяти, куда будут скопированы входящие данные.
                len - максимальный размер этого буфера в байтах.
                flags - битовая маска, модифицирующая поведение приёма 

            чтение входящих данных в connected сокете 

            ! recv vs recvfrom: Вызов recv обычно используется соединенном сокете (см. connect(2)) и идентичен вызову recvfrom с параметром from, установленным в NULL:
                recv(sockfd, buf, len, flags)
                recvfrom(sockfd, buf, len, flags, NULL, NULL)

            в моем случае: recv(client_sock, buffer, BUFFER_SIZE, 0)

            https://www.opennet.ru/man.shtml?topic=recv&category=2&russian=0

    клиент: 
        ЛОГИКА РАБОТЫ: 
            1 socket() - создал TCP-сокет
            2 inet_pton() - конвертировал IP адрес сервера из строки в бинарный вид
            3 connect() - установил TCP-соединение с сервером
            4 ввод текста через fgets()
            5 send() - отправил введённую строку серверу
            6 recv() - получил эхо-ответ(то же самое) от сервера, печатаю
            7 close() - после завершения обмена закрыл сокет

        connect
            int connect(int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen); 
                sockfd - дескриптор, определяющий неподключенные сокеты
                serv_addr - указатель на структуру sockaddr, с которой должно быть установлено соединение
                addrlen - длина структуры sockaddr в байтах, на которую указывает параметр name

            устанавливает соединение с указанным первым параметром сокетом

            в моем случае: 
                connect(client_fd, (struct sockaddr*)&server_addr, sizeof(server_addr))

            https://learn.microsoft.com/ru-ru/windows/win32/api/winsock2/nf-winsock2-connect
            https://www.opennet.ru/man.shtml?topic=connect&category=2&russian=0

        send
            int send(int s, char * buf, int len, int flags)
                s - сокет-дескриптор, в который записываются данные
                buf - адрес буфера с записываемыми данными
                len - длина этого буфера
                flags - комбинация битовых флагов, управляющих режимами записи. Если аргумент flags равен нулю, то запись в сокет 
                    (и, соответственно, считывание ) происходит в порядке поступления байтов.
            
            запись данных в connected сокет

            ! send vs sendto: обе функции при успешном возвращают число отправленных байт, или -1 при ошибке. 
                НО:
                    send() работает только на подключённых (connected) сокетах и не требует указания адреса получателя
                    sendto() может применяться на любых сокетах (как подключённых, так и неконнектных) и дополнительно принимает параметры адреса получателя
                ответ: https://www.reddit.com/r/C_Programming/comments/xlwsdy/send_vs_sendto/
                    send() is for connected sockets (ie, TCP is the most common usage), 
                        while sendto() is for sockets which don't require a connected state ( ie, UDP)
            send(sockfd, buf, len, flags);
            sendto(sockfd, buf, len, flags, NULL, 0);


            https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=send&category=2
    