1. UDP - эхо сервер:
    a. Сделайте UDP-сервер, который принимает данные от клиентов и пересылает их обратно клиенту.
    b. Напишите UDP-клиента, для теста UDP-сервера.
    c. Проверьте, что UDP-сервер, работает с несколькими клиентами.

    как запускать: 
        1 терминал
            g++ server.cpp -o server && ./server
        2 терминал
            g++ client.cpp -o client && ./client
        3 терминал
            g++ client.cpp -o client && ./client

    struct sockaddr_in
        struct sockaddr_in {
            sa_family_t     sin_family;     /* AF_INET */
            in_port_t       sin_port;       /* Port number */
            struct in_addr  sin_addr;       /* IPv4 address */
        };

        в моем случае: 
            сервер: 
                server_addr.sin_family = AF_INET; // IP адрес к которому будет привязан сокет (IPv4)
                server_addr.sin_port = htons(PORT); // номер порта к которому будет привязан сокет
            клиент: 
                server_addr.sin_family = AF_INET;
                server_addr.sin_port = htons(PORT);

        Структура sockaddr_in описывает сокет для работы с протоколами IP. 
            Значение поля sin_family всегда равно AF_INET.
            Поле sin_port содержит номер порта который намерен занять процесс. 
                Если значение этого поля равно нулю, то операционная система сама выделит свободный номер порта для сокета. 
            Поле sin_addr типа структуры in_addr, содержит IP адрес к которому будет привязан сокет.
                Структура in_addr содержит поле s_addr. Этому полю можно присвоить 32х битное значение IP адреса. 

        https://www.opennet.ru/docs/RUS/socket/node4.html
        https://man7.org/linux/man-pages/man3/sockaddr.3type.html
        https://learn.microsoft.com/ru-ru/windows/win32/api/ws2def/ns-ws2def-sockaddr_in

    htons
        uint16_t htons(uint16_t hostshort);
        Функция htons() преобразует узловой порядок расположения байтов 
            положительного короткого целого hostshort в сетевой порядок расположения байтов.
        
        https://www.opennet.ru/man.shtml?topic=htons&category=3&russian=0

    socket
        int socket (int domain, int type, int protocol)
            domain - cпецификация семейства адресов
            type - cпецификация типа для нового сокета
            protocol - Используемый протокол. 
                Возможные параметры параметра протокола относятся к указанному семейству адресов и типу сокета. 

        в моем случае:
            socket(AF_INET, SOCK_DGRAM, 0)
                AF_INET - cемейство адресов IPv4 
                SOCK_DGRAM - тот тип сокета использует протокол UDP для семейства адресов Интернета. Посылаем ДАТАГРАМЫ 
                0 - вызывающий объект не хочет указывать протокол, и поставщик услуг выберет протокол для использования

        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock2/nf-winsock2-socket
        https://www.opennet.ru/docs/RUS/linux_base/node245.html

    bind
        int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
            sockfd - дескриптор, определяющий несвязанный сокет, ему мы функцией bind задаем адрес
            addr - указатель на структуру sockaddr локального адреса, назначаемого связанному сокету
            addrlen - длина (в байтах) значения, на которое указывает addr

        в моем случае: 
            bind(server_fd, (const struct sockaddr*)&server_addr, sizeof(server_addr))

        функция используется сервером для присваивания сокету имени. До выполнения функции bind (т.е. присваивания 
            какого-либо имени, вид которого зависит от адресного домена) сокет недоступен программам-клиентам.

        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock/nf-winsock-bind
        https://www.opennet.ru/docs/RUS/linux_base/node246.html

    sendto
        ssize_t sendto(int s, const void *msg, size_t len, int flags, const struct sockaddr *to, socklen_t tolen);
            s - Дескриптор, определяющий сокет
            msg - Указатель на буфер, содержащий передаваемые данные.
            len - Длина (в байтах) данных, на которые указывает параметр buf.
            flags - Набор флагов, указывающих способ вызова.
            to - Необязательный указатель на структуру sockaddr, содержащую адрес целевого сокета.
            tolen - Размер (в байтах) адреса, на который указывает параметр to.

        в моем случае:
            sendto(server_fd, buffer, msg_len, 0, (const struct sockaddr*)&client_addr, client_len)

        важно: параметр flags является битовой маской и может содержать такие флаги: 
            MSG_CONFIRM - Сообщает (на уровне связи), что процесс пересылки произошел: вы получаете успешный ответ с другой стороны.
            ...

        Функция sendto используется для записи исходящих данных в сокет. 

        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock2/nf-winsock2-sendto
        https://www.opennet.ru/man.shtml?topic=sendto&category=2&russian=0
    
    recvfrom
        int recvfrom(int s, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);
            s - Дескриптор, определяющий привязанный сокет.
            buf - Буфер для входящих данных.
            len - Длина (в байтах) буфера, на который указывает параметр buf .
            flags - Набор параметров, которые изменяют поведение вызова функции за пределами параметров, указанных для связанного сокета. 
            from - Необязательный указатель на буфер в структуре sockaddr , который будет содержать исходный адрес при возврате.
            fromlen - Необязательный указатель на размер (в байтах) буфера, на который указывает параметр from.

        в моем случае:
            сервер: recvfrom(server_fd, buffer, BUFFER_SIZE, 0, (sockaddr*)&client_addr, &client_len)
            клиент: recvfrom(client_fd, buffer, BUFFER_SIZE, 0, NULL, NULL)
            ?   2 последних параметра у клиента NULL - что это значит?
            -   информация об отправителе сообщения не сохраняется на клиенте (ибо не нужна)

        Системный вызовы recvfrom используются для получения сообщений из сокета. Возвращает длину сообщения при успешном завершении.
        Аргумент flags системного вызова recv формируется с помощью объединения логической операцией ИЛИ 
            одного или более нижеследующих значений:
            MSG_WAITALL - просит подождать, пока не придет полное запрошенное количество данных.
            ...

        https://www.opennet.ru/man.shtml?topic=recvfrom&category=2&russian=0
        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock2/nf-winsock2-recvfrom

    inet_ntoa
        char *inet_ntoa(struct in_addr in);
        
        преобразует IP-адрес in, заданный в сетевом порядке расположения байтов, в стандартный строчный вид ASCII, завершающуюся NULL. 
            Строка располагается в статически размещенном буфере; последующие вызовы перепишут его данные.

        у меня используется для преобразования IPv4 адреса из бинарного формата (используется в сетевых структурах) 
            в читаемую строку в формате типа "192.168.1.1"

        https://learn.microsoft.com/ru-ru/windows/win32/api/winsock2/nf-winsock2-inet_ntoa
        https://www.opennet.ru/man.shtml?topic=inet_ntoa&category=3&russian=0#:~:text=Функция%20inet_ntoa()%20преобразует%20IP,последующие%20вызовы%20перепишут%20его%20данные.

    inet_pton
        int inet_pton(int af, const char *src, void *dst);
            af - cпецификация семейства адресов (как в socket())
            src - указатель на строку, завершающуюся значением NULL, которая содержит текстовое 
                представление IP-адреса для преобразования в двоичную форму.
            dst - указатель на буфер, в котором будет храниться двоичное представление IP адреса. 
                IP адрес возвращается в порядке байтов сети.
        
        в моем случае: 
            inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr)
                AF_INET - cемейство адресов IPv4 
                "127.0.0.1" - преобразуемый IP адрес
                &server_addr.sin_addr - указатель на буфер, куда записать двоичное представление IP адреса

        Данная функция преобразует строку символов src в сетевой адрес (типа af), затем копирует полученную структуру с адресом в dst.
        По понятному: преобразует IP адрес из человекочитаемого строкового формата в бинарный, понятный сетевым функциям.

        https://www.opennet.ru/man.shtml?topic=inet_pton&category=3&russian=0
        https://learn.microsoft.com/ru-ru/windows/win32/api/ws2tcpip/nf-ws2tcpip-inet_pton

    ?   Что такое IP и порт?
    -   IP - числовой идентификатор хоста в сети, работающей по протоколу IP. Должен быть уникален для любого устройства в сети.
        СПРАВКА:    хост - устройство, объединяющее сеть.
                    IP (межсетевой протокол) - обеспечивает передачу данных без гарантии доставки.
        Порт - идентификатор программы или процесса, которые обслуживают сетевые соединения на заданном IP-адресе

        Представьте, что у вас дома 2 компьютера и они подключены к одному роутеру. Для всего интернета IP адрес этих 
            компьютеров одинаковый (так как внешний IP, который виден в интернете есть только у роутера). 
            В этом случае, чтобы обратиться к конкретному компьютеру, нужен порт. Например, на роутере настроено, 
            что у одного из компьютеров открыт порт 8245. Роутер имеет IP 95.84.208.79. Тогда обратиться к этому 
            компьютеру можно так: 95.84.208.79:8245
            
            IP адрес — это номер квартиры друга.
            Порт — это комната, в которой живёт друг

            https://qna.habr.com/q/844233#:~:text=Айпи-адрес%20-%20это%20адрес%20конкретного,конкретном%20компьютере%20шлется%20запрос%2C%20т.
            про порты: https://www.ittelo.ru/news/chto-takoe-port-v-seti/?srsltid=AfmBOorp-2zA1Mnurqtuc70K-Lrz_JDda0OzRAAma_09TCCyp9eXcH9W
